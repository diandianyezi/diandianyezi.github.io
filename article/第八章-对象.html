<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.61" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://vuepress-theme-hope-v2-demo.netlify.app/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html"><meta property="og:site_name" content="Yezi’s Blog"><meta property="og:title" content="对象、类与面向对象编程"><meta property="og:description" content="对象、类与面向对象编程 理解对象 属性的类型 ECMA-262使用一些内部特性来描述属性的特征。这些特征是由为JavaScript实现引擎的规范定义的。 属性分为两种：数据属性和访问器属性 数据属性 数据属性包含一个保存数据值的位置。 四个特性描述： Configurable：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认所有直接定义在对象上的属性为true Enumerable：表示属性是否可以通过for-in循环返回。默认所有直接定义在对象上的属性为true Writable：表示属性是否可以被修改。默认所有直接定义在对象上的属性为true Value：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。默认值所有直接定义在对象上的属性为undefined"><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2022-11-21T07:45:14.000Z"><meta property="article:tag" content="类"><meta property="article:tag" content="对象"><meta property="article:published_time" content="2022-11-04T00:00:00.000Z"><meta property="article:modified_time" content="2022-11-21T07:45:14.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"对象、类与面向对象编程","image":[""],"datePublished":"2022-11-04T00:00:00.000Z","dateModified":"2022-11-21T07:45:14.000Z","author":[]}</script><link rel="icon" href="/favicon.icon"><link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#46bd87"><link rel="apple-touch-icon" href="/assets/icon/apple-icon-152.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="msapplication-TileImage" content="/assets/icon/ms-icon-144.png"><meta name="msapplication-TileColor" content="#ffffff"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><title>对象、类与面向对象编程 | Yezi’s Blog</title><meta name="description" content="对象、类与面向对象编程 理解对象 属性的类型 ECMA-262使用一些内部特性来描述属性的特征。这些特征是由为JavaScript实现引擎的规范定义的。 属性分为两种：数据属性和访问器属性 数据属性 数据属性包含一个保存数据值的位置。 四个特性描述： Configurable：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认所有直接定义在对象上的属性为true Enumerable：表示属性是否可以通过for-in循环返回。默认所有直接定义在对象上的属性为true Writable：表示属性是否可以被修改。默认所有直接定义在对象上的属性为true Value：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。默认值所有直接定义在对象上的属性为undefined">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-5e611b4f.css" as="style"><link rel="stylesheet" href="/assets/style-5e611b4f.css">
    <link rel="modulepreload" href="/assets/app-74f1da39.js"><link rel="modulepreload" href="/assets/framework-609d4fec.js"><link rel="modulepreload" href="/assets/第八章-对象.html-bfdc06ba.js"><link rel="modulepreload" href="/assets/第八章-对象.html-d4fd51f4.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="Yezi’s Blog"><!----><span class="site-name hide-in-pad">Yezi’s Blog</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="首页"><span class="font-icon icon iconfont icon-home" style=""></span>首页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/article/" class="nav-link active" aria-label="文章"><span class="font-icon icon iconfont icon-edit" style=""></span>文章<!----></a></div><div class="nav-item hide-in-mobile"><a href="/guide/" class="nav-link" aria-label="使用指南"><span class="font-icon icon iconfont icon-creative" style=""></span>使用指南<!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><!----><!----><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!----><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#理解对象" class="router-link-active router-link-exact-active nav-link sidebar-link sidebar-heading" aria-label="理解对象"><!---->理解对象<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#属性的类型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="属性的类型"><!---->属性的类型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#定义多个属性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="定义多个属性"><!---->定义多个属性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#读取属性的特性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="读取属性的特性"><!---->读取属性的特性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#合并对象" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="合并对象"><!---->合并对象<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#对象标识及相等判定" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="对象标识及相等判定"><!---->对象标识及相等判定<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#增强的对象语法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="增强的对象语法"><!---->增强的对象语法<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#创建对象" class="router-link-active router-link-exact-active nav-link sidebar-link sidebar-heading" aria-label="创建对象"><!---->创建对象<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#概述" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="概述"><!---->概述<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#工厂模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="工厂模式"><!---->工厂模式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#构造函数模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="构造函数模式"><!---->构造函数模式<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#继承" class="router-link-active router-link-exact-active nav-link sidebar-link sidebar-heading" aria-label="继承"><!---->继承<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#原型链-1" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="原型链"><!---->原型链<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#盗用构造函数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="盗用构造函数"><!---->盗用构造函数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#组合继承" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="组合继承"><!---->组合继承<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#原型式继承" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="原型式继承"><!---->原型式继承<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#寄生式继承" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="寄生式继承"><!---->寄生式继承<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#寄生式组合继承" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="寄生式组合继承"><!---->寄生式组合继承<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->对象、类与面向对象编程</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://diandianyezi.github.io/" target="_blank" rel="noopener noreferrer">Yezi</a></span><span property="author" content="Yezi"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2022-11-04T00:00:00.000Z"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><span class="page-category-item category5 clickable" role="navigation">JavaScript</span><meta property="articleSection" content="JavaScript"></span><span class="page-tag-info" aria-label="标签🏷" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><span class="page-tag-item tag2 clickable" role="navigation">类</span><span class="page-tag-item tag2 clickable" role="navigation">对象</span><meta property="keywords" content="类,对象"></span><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 19 分钟</span><meta property="timeRequired" content="PT19M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#理解对象" class="router-link-active router-link-exact-active toc-link level2">理解对象</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#属性的类型" class="router-link-active router-link-exact-active toc-link level3">属性的类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#定义多个属性" class="router-link-active router-link-exact-active toc-link level3">定义多个属性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#读取属性的特性" class="router-link-active router-link-exact-active toc-link level3">读取属性的特性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#合并对象" class="router-link-active router-link-exact-active toc-link level3">合并对象</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#对象标识及相等判定" class="router-link-active router-link-exact-active toc-link level3">对象标识及相等判定</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#增强的对象语法" class="router-link-active router-link-exact-active toc-link level3">增强的对象语法</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#创建对象" class="router-link-active router-link-exact-active toc-link level2">创建对象</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#概述" class="router-link-active router-link-exact-active toc-link level3">概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#工厂模式" class="router-link-active router-link-exact-active toc-link level3">工厂模式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#构造函数模式" class="router-link-active router-link-exact-active toc-link level3">构造函数模式</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#继承" class="router-link-active router-link-exact-active toc-link level2">继承</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#原型链-1" class="router-link-active router-link-exact-active toc-link level3">原型链</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#盗用构造函数" class="router-link-active router-link-exact-active toc-link level3">盗用构造函数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#组合继承" class="router-link-active router-link-exact-active toc-link level3">组合继承</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#原型式继承" class="router-link-active router-link-exact-active toc-link level3">原型式继承</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#寄生式继承" class="router-link-active router-link-exact-active toc-link level3">寄生式继承</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/article/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html#寄生式组合继承" class="router-link-active router-link-exact-active toc-link level3">寄生式组合继承</a></li><!----><!--]--></ul><!--]--></ul></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><h1 id="对象、类与面向对象编程" tabindex="-1"><a class="header-anchor" href="#对象、类与面向对象编程" aria-hidden="true">#</a> 对象、类与面向对象编程</h1><h2 id="理解对象" tabindex="-1"><a class="header-anchor" href="#理解对象" aria-hidden="true">#</a> 理解对象</h2><h3 id="属性的类型" tabindex="-1"><a class="header-anchor" href="#属性的类型" aria-hidden="true">#</a> 属性的类型</h3><p>ECMA-262使用一些内部特性来描述属性的特征。这些特征是由为JavaScript实现引擎的规范定义的。</p><p>属性分为两种：数据属性和访问器属性</p><h4 id="数据属性" tabindex="-1"><a class="header-anchor" href="#数据属性" aria-hidden="true">#</a> 数据属性</h4><p>数据属性包含一个保存数据值的位置。</p><h5 id="四个特性描述" tabindex="-1"><a class="header-anchor" href="#四个特性描述" aria-hidden="true">#</a> 四个特性描述：</h5><ul><li><code>Configurable</code>：表示属性<strong>是否可以通过delete删除并重新定义</strong>，<strong>是否可以修改它的特性</strong>，以及<strong>是否可以把它改为访问器属性</strong>。默认所有直接定义在对象上的属性为<code>true</code></li><li><code>Enumerable</code>：<strong>表示属性是否可以通过for-in循环返回</strong>。默认所有直接定义在对象上的属性为<code>true</code></li><li><code>Writable</code>：表示属性是否可以被修改。默认所有直接定义在对象上的属性为<code>true</code></li><li><code>Value</code>：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。默认值所有直接定义在对象上的属性为<code>undefined</code></li></ul><p><code>Object.defineProperty()</code>方法 可以修改属性的默认特性。参数：要添加属性的对象、属性名、描述符对象</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// Object.defineProperty 接收3个参数：要给其添加的属性的对象、属性名、描述符对象</span>
<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">&#39;name&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// 将configurable设置为false，意味着这个属性不能从对象上删除。一个属性被设置为不可配置后，就不能再变回可配置的了。再次调用definePropperty并修改非writable属性会导致错误。</span>
  <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">&#39;test name&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">/*
	这个属性的值就不能再修改了，在非严格模式下尝试给这个属性重新赋值会被忽略。在严格模式下，尝试修		改只读属性的值会抛出错误。
*/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在调用<code>Object.defineProperty()</code>时，<code>configurable</code>、<code>enumerable</code>和<code>writable</code>的值如果不指定，则都默认为<code>false</code>。</p><h4 id="访问器属性" tabindex="-1"><a class="header-anchor" href="#访问器属性" aria-hidden="true">#</a> 访问器属性</h4><p><strong>不包含数据值</strong>，相反的，它们包含一个<strong>获取 getter</strong>函数 和 一个<strong>设置 setter</strong> 函数，不过这俩函数不是必须的。</p><p>在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。</p><p>在写入访问器属性时，会调用设置函数并传入心致，这个函数必须决定对数据做出什么修改。</p><h5 id="四个特性描述符" tabindex="-1"><a class="header-anchor" href="#四个特性描述符" aria-hidden="true">#</a> 四个特性描述符：</h5><ul><li>Configurable：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性都为true。</li><li>Enumerable：是否可以通过for-in循环返回，默认所有直接定义在对象上的属性为true</li><li>Get：获取函数，在读取属性时调用，默认值为undefined</li><li>Set：设置函数，在写入属性时调用。默认值为undefined</li></ul><p><code>Object.defineProperty</code>定义访问器属性</p><p>getter和setter函数不一定都要定义。</p><p>只定义获取函数意味着属性是只读的，尝试修改属性会被忽略。严格模式下会抛出错误。</p><p>只有一个设置函数的属性是不能读取的，非严格模式下读取会返回undefined，严格模式下会抛出错误。</p><blockquote><p>在不支持Object.defineProperty()的浏览器中没有办法修改[[Configurable]]或[[Enumerable]]。</p></blockquote><h3 id="定义多个属性" tabindex="-1"><a class="header-anchor" href="#定义多个属性" aria-hidden="true">#</a> 定义多个属性</h3><p><code>Object.defineProperties()</code>接收两个参数：要添加属性或修改属性的对象、另一个描述对象</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> book <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

Objec<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token string-property property">&#39;year_&#39;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">2017</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">edition</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span><span class="token number">1</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">year</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>newValue <span class="token operator">&gt;</span> <span class="token number">2017</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>year_ <span class="token operator">=</span> newValue
        <span class="token keyword">this</span><span class="token punctuation">.</span>edition <span class="token operator">+=</span> newValue <span class="token operator">-</span> <span class="token number">2017</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>year_
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 上述对象的数据属性的configurable、enumerable和wraitable都为false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="读取属性的特性" tabindex="-1"><a class="header-anchor" href="#读取属性的特性" aria-hidden="true">#</a> 读取属性的特性</h3><p><code>Object.getOwnPropertyDescriptor()</code>可以获取指定属性的属性描述符。参数： 对象、属性名</p><p>ECMAScript 2017新增了<code>Object.getOwnPropertyDescriptors()</code>静态方法，参数为对象</p><h3 id="合并对象" tabindex="-1"><a class="header-anchor" href="#合并对象" aria-hidden="true">#</a> 合并对象</h3><p><code>Object.assign()</code>：接收一个目标对象和一个后多个源对象作为参数，将每个源对象中可枚举（Object.propertyIsEnumerable()返回true）和自有属性（Object.hasOwnProperty()返回true）复制到目标对象。以字符串和符号为键的属性会被复制。对每个符合条件的属性，这个方法会使用源对象上的[[Get]]取得属性的值，然后使用目标对象上的[[Set]]设置属性的值。</p><p>对每个源对象执行的是浅复制。</p><p>不能在两个对象间转移获取函数和设置函数。</p><p>没有“回滚”之前赋值的概念。可能只会完成部分复制的方法。</p><h3 id="对象标识及相等判定" tabindex="-1"><a class="header-anchor" href="#对象标识及相等判定" aria-hidden="true">#</a> 对象标识及相等判定</h3><p><code>===</code>在下面情况下 无能为力：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">-</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token operator">+</span><span class="token number">0</span> <span class="token comment">// true</span>
<span class="token operator">+</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token number">0</span> <span class="token comment">// true</span>
<span class="token operator">-</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token number">0</span> <span class="token comment">//true</span>
<span class="token number">NaN</span> <span class="token operator">===</span> <span class="token number">NaN</span> <span class="token comment">// false</span>
<span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以Es6新增了<code>Object.is</code>方法，必须接收两个参数<code>Object.is(a, b)</code></p><p>如果需要检查超过两个值，递归地利用相等性传递即可：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">checkEqual</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> <span class="token operator">...</span>rest</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> reset<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>reset<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">||</span> <span class="token function">checkEqual</span><span class="token punctuation">(</span><span class="token operator">...</span>rest<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="增强的对象语法" tabindex="-1"><a class="header-anchor" href="#增强的对象语法" aria-hidden="true">#</a> 增强的对象语法</h3><p>本节所有对象语法同样适用于ECMAScript6的类</p><h4 id="属性值简写" tabindex="-1"><a class="header-anchor" href="#属性值简写" aria-hidden="true">#</a> 属性值简写</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token punctuation">{</span>
    name
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> p
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="可计算属性" tabindex="-1"><a class="header-anchor" href="#可计算属性" aria-hidden="true">#</a> 可计算属性</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> nameKey <span class="token operator">=</span> <span class="token string">&#39;name&#39;</span>

<span class="token keyword">let</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>nameKey<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token string">&#39;test name&#39;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为被当做JavaScript表达式求值，所以可计算属性本身可以是复杂的表达式，在实例化时再求值。</p><blockquote><p>注意：可计算属性表达式中抛出任何错误都会中断对象的创建。如果计算属性的表达式有副作用，那就要小心了，因为如果表达式抛出错误，那么之前完成的计算是不能回滚的。</p></blockquote><h4 id="简写方法名" tabindex="-1"><a class="header-anchor" href="#简写方法名" aria-hidden="true">#</a> 简写方法名</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name_</span><span class="token operator">:</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">,</span>
  <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
  <span class="token punctuation">}</span>，
  <span class="token keyword">set</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name_ <span class="token operator">=</span> name
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name_
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 简写方法名与可计算属性键相互兼容</span>
<span class="token keyword">const</span> methodKey <span class="token operator">=</span> <span class="token string">&#39;sayName&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>methodKey<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&#39;My name is ${name}&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简写方法名对获取函数和设置函数也是适用的。</p><h4 id="对象解构" tabindex="-1"><a class="header-anchor" href="#对象解构" aria-hidden="true">#</a> 对象解构</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> personName<span class="token punctuation">,</span> age<span class="token punctuation">}</span> <span class="token operator">=</span> p
console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>personName<span class="token punctuation">,</span> age<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解构赋值不一定与对象的属性匹配。也可以在解构赋值的同事定义默认值</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> job<span class="token operator">=</span><span class="token string">&#39;test job&#39;</span><span class="token punctuation">}</span> <span class="token operator">=</span> p
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>解构在内部使用函数<code>ToObject()</code>(不能在运行时环境中直接访问)<strong>把源数据结构转换为对象</strong>。这意味着在对象结构的上下文中，原始值会被当成对象。这也意味着，<code>null</code>和 <code>undefined</code>不能被结构，会被抛出错误。</p><p><img src="https://raw.githubusercontent.com/diandianyezi/typora-images/master/img/202205232239409.png" alt="image-20220523223927350"></p><p><strong>解构并不要求变量必须在解构表达式中声明。不过，如果是事先声明的变量赋值，则赋值表达式必须包含在一对括号中：</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> personName<span class="token punctuation">,</span>personAge<span class="token punctuation">;</span>

<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;test&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span>
<span class="token punctuation">}</span>

<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span>personName<span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> personAge<span class="token punctuation">}</span> <span class="token operator">=</span> person<span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>personName<span class="token punctuation">,</span> personAge<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="嵌套解构" tabindex="-1"><a class="header-anchor" href="#嵌套解构" aria-hidden="true">#</a> 嵌套解构</h5><p>解构来复制对象属性</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;Matt&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
  <span class="token literal-property property">job</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">&#39;engineer&#39;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> personCopy <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> personCopy<span class="token punctuation">.</span>name<span class="token punctuation">,</span>
  <span class="token literal-property property">age</span><span class="token operator">:</span> personCopy<span class="token punctuation">.</span>age<span class="token punctuation">,</span>
  <span class="token literal-property property">job</span><span class="token operator">:</span> personCopy<span class="token punctuation">.</span>job
<span class="token punctuation">}</span> <span class="token operator">=</span> person<span class="token punctuation">)</span><span class="token punctuation">;</span>

person<span class="token punctuation">.</span>job<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">&#39;Hacker&#39;</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>personCopy<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在外层属性没有定义的情况下不能使用嵌套解构。无论源对象还是目标对象都一样。</p><h5 id="部分解构" tabindex="-1"><a class="header-anchor" href="#部分解构" aria-hidden="true">#</a> 部分解构</h5><p>涉及多个属性的解构赋值是一个输出无关的顺序化操作。如果一个解析表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分。</p><h5 id="参数上下文匹配" tabindex="-1"><a class="header-anchor" href="#参数上下文匹配" aria-hidden="true">#</a> 参数上下文匹配</h5><p>在函数参数列表中也可进行解构赋值。对参数的解构赋值不会影响<code>arguments</code>对象，但可以在函数签名中声明在函数体内使用局部变量。</p><h2 id="创建对象" tabindex="-1"><a class="header-anchor" href="#创建对象" aria-hidden="true">#</a> 创建对象</h2><h3 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h3><p>ES5.1 没有正式支持面向对象的结构，比如类或继承。巧妙地运用原型式继承可以成功地模拟同样的行为。</p><p>ES6 开始正式支持类和继承。ES6的类 旨在完全涵盖之前规范设计的基本原型的继承模式。</p><p>ES6的类都仅仅是封装了ES5.1构造函数加原型继承的语法糖而已。</p><h3 id="工厂模式" tabindex="-1"><a class="header-anchor" href="#工厂模式" aria-hidden="true">#</a> 工厂模式</h3><p>用于抽象创建对象的过程。</p><p>下面的例子展示了一种按照特定接口创建对象的方式：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  o<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  o<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  o<span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>
  o<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">return</span> o
<span class="token punctuation">}</span>

<span class="token keyword">let</span> person1 <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">&#39;test name1&#39;</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> person2 <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">&#39;test name2&#39;</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 但是没有解决对象标识问题（即新创建的对象是什么类型）。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>没有解决对象标识问题（即新创建的对象是什么类型）</p></blockquote><h3 id="构造函数模式" tabindex="-1"><a class="header-anchor" href="#构造函数模式" aria-hidden="true">#</a> 构造函数模式</h3><p>以函数的形式为自己的对象类型定义属性和方法。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
  <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job
  
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>与工厂模式的区别：</p><ul><li>没有显式地创建对象；</li><li>属性和方法直接赋值给了this</li><li>没有return</li></ul><h4 id="使用new操作符-创建实例。" tabindex="-1"><a class="header-anchor" href="#使用new操作符-创建实例。" aria-hidden="true">#</a> <strong>使用<code>new</code>操作符</strong> 创建实例。</h4><p>以这种方式调用构造函数会执行如下操作：</p><ol><li><strong>在内存中创建一个新对象；</strong></li><li><strong>这个新对象内部的<code>[[Prototype]]</code>特性被赋值为构造函数的<code>prototype</code>属性。</strong></li><li><strong>构造函数内部的 <code>this</code>被赋值为这个新对象（即this指向新对象）；</strong></li><li><strong>执行构造函数内部的代码（给新对象添加属性）；</strong></li><li><strong>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</strong></li></ol><blockquote><p><u>对象的<code>constructor</code>属性指向构造函数</u></p></blockquote><p><strong><code>constructor</code>本来是用于标识对象类型的</strong>。不过，一般认为<code>instanceof</code>操作符是确定对象类型更可靠的方式。</p><p><strong>实例化的时候，如果不想传参数，那么构造函数后面的括号可加可不加。只要有new操作符，可以调用相应的构造函数。</strong></p><h4 id="构造函数也是函数" tabindex="-1"><a class="header-anchor" href="#构造函数也是函数" aria-hidden="true">#</a> 构造函数也是函数</h4><p>构造函数与普通函数唯一的区别就是 <strong>调用方式不同</strong></p><blockquote><p>任何函数只要使用new操作符调用就是构造函数，而不使用new操作符调用的函数就是普通函数。</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 作为构造函数</span>
<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&#39;name&#39;</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">&#39;soft engineer&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

person<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 作为函数调用</span>
<span class="token function">Person</span><span class="token punctuation">(</span><span class="token string">&#39;name2&#39;</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">&#39;hihi&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 添加到window对象</span>
window<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 在另一个对象的作用域中调用</span>
<span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token string">&#39;name3&#39;</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token string">&#39;hahaha&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
o<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#39;name3&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在调用一个函数而没有明确设置this值的情况下（即没有作为对象的方法调用，或者没有使用call/apply调用），this始终指向Global对象（在浏览器中就是window对象）。</p></blockquote><h4 id="构造函数的问题" tabindex="-1"><a class="header-anchor" href="#构造函数的问题" aria-hidden="true">#</a> 构造函数的问题</h4><p><strong>其定义的方法会在每个实例上都创建一遍</strong>。所以两个实例的sayName方法不是同一个方法，<strong>这样会带来不同的作用域链和标识符解析。</strong></p><p>因为做一样的事，没必要定义两个不同的Function实例。<strong>况且，this对象可以把函数与对象的绑定推迟到运行时。</strong></p><p>虽然可以将函数定义在构造函数外部以解决这个问题，但是会污染全局作用域，而且自定义类型引用的代码都不能好好聚集在一起。这个问题可以通过<strong>原型模式</strong>解决</p><h4 id="原型模式" tabindex="-1"><a class="header-anchor" href="#原型模式" aria-hidden="true">#</a> 原型模式</h4><p>每个函数都会创建一个<code>prototype</code>属性，这个属性是一个对象，**包含应该由特定引用类型的实例共享的属性和方法。**是通过调用构造函数创建的对象的原型。</p><p>使用原型对象的好处是，<strong>在它上面定义的属性和方法可以被对象实例共享</strong>。</p><h5 id="理解原型" tabindex="-1"><a class="header-anchor" href="#理解原型" aria-hidden="true">#</a> 理解原型</h5><p>无论何时，<strong>只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype属性（指向原型对象）</strong>。</p><p>默认情况下，<strong>所有原型对象自动获得一个名为contructor属性</strong>，指回与之关联的构造函数。默认值值获得constructor属性，其他方法从Object继承</p><p><strong>每次调用构造函数创建一个新实例，这个实例内部的<code>[[Prototype]]</code>指针会被赋值为构造函数的原型对象</strong>。脚本中没有访问这个 <code>[[Prototype]]</code>特性的标准，但在浏览器里会在每个对象暴露<code>__proto__</code>属性，通过这个属性可以访问对象的原型。</p><blockquote><p>实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">/* 
	构造函数可以是函数表达式，也可以是函数声明
	function Person() {}
	let person = function() {}
*/</span>

<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 声明之后 构造函数就有了一个与之关联的原型对象：</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">//</span>
<span class="token comment">// {</span>
<span class="token comment">//   constructor: f Person(),</span>
<span class="token comment">//   __proro__: Object</span>
<span class="token comment">// }</span>

<span class="token comment">// 如前所述，构造函数有一个prototype属性，引用其原型对象，原型对象也有一个</span>
<span class="token comment">// contructor属性，引用这个构造函数</span>
<span class="token comment">// 两者循环引用</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token comment">// 正常的原型链都会终止于Object的原型对象，Object原型的原型是null</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// true</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token class-name">__proto__</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span> <span class="token comment">// true</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// true</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// constructor: ƒ Object()</span>
<span class="token comment">// hasOwnProperty: ƒ hasOwnProperty()</span>
<span class="token comment">// isPrototypeOf: ƒ isPrototypeOf()</span>
<span class="token comment">// propertyIsEnumerable: ƒ propertyIsEnumerable()</span>
<span class="token comment">// toLocaleString: ƒ toLocaleString()</span>
<span class="token comment">// toString: ƒ toString()</span>
<span class="token comment">// valueOf: ƒ valueOf()</span>
<span class="token comment">// __defineGetter__: ƒ __defineGetter__()</span>
<span class="token comment">// __defineSetter__: ƒ __defineSetter__()</span>
<span class="token comment">// __lookupGetter__: ƒ __lookupGetter__()</span>
<span class="token comment">// __lookupSetter__: ƒ __lookupSetter__()</span>
<span class="token comment">// __proto__: （…）</span>
<span class="token comment">// get __proto__: ƒ __proto__()</span>
<span class="token comment">// set __proto__: ƒ __proto__()</span>

<span class="token comment">// 构造函数、原型对象和实例是3个不同的对象</span>
<span class="token comment">/* 
	实例通过__proro__链接到原型对象，
	实际上 指向隐藏特性[[Prototype]]
	
	构造函数通过Prototype属性链接到原型对象
	实例与构造函数没有直接联系，与原型对象有直接联系
*/</span>

<span class="token keyword">let</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span><span class="token class-name">__proto__</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token comment">// 同一个构造函数创建的两个实例，共享一个原型对象：</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> person2<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token comment">// instanceof 检查实例的原型链中是否包含指定构造函数的原型：</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1 <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1 <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实例对象、构造函数、原型对象之间的关系如下图所示：</p><img src="https://raw.githubusercontent.com/diandianyezi/typora-images/master/img/202205241024793.png" alt="image-20220524102456711" style="zoom:47%;"><h5 id="isprototype-getprototypeof-setprototypeof" tabindex="-1"><a class="header-anchor" href="#isprototype-getprototypeof-setprototypeof" aria-hidden="true">#</a> isPrototype getPrototypeOf setPrototypeOf</h5><p>并不是所有实现都暴露了 <code>[[Prototype]]</code>，但是可以使用 <code>isPrototypeOf</code>方法确定两个对象之间的这种关系。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span> <span class="token comment">// true</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>ECMAScript的<code>Object</code>类型有一个方法叫<code>Object.getPrototypeOf()</code>，返回参数的内部特性<code>[[Prototype]]</code>的值</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token comment">// true</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>setPrototypeOf</code>方法，可以向实例的私有特性 <code>[[Prototype]]</code>写入一个新值。这样就可以重写一个对象的原型继承关系。</p><blockquote><p><code>Object.setPrototypeOf</code> 可能会严重影响代码性能。因为不仅仅是执行<code>Object.setPrototypeOf()</code>语句那么简单，而是会涉及所有访问了那些修改过<code>[[Prototype]]</code>的对象的代码</p></blockquote><p>为避免造成性能下降，可以通过<code>Object.create()</code>来创建一个新对象，同时为其指定原型：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> biped <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">numLegs</span><span class="token operator">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> person <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>biped<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span> <span class="token operator">===</span> biped<span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="原型链" tabindex="-1"><a class="header-anchor" href="#原型链" aria-hidden="true">#</a> 原型链</h5><p>**<code>constructor</code>**属性只存在与原型对象</p><p><code>hasOwnProperty()</code>方法用于确定某个属性是在实例上还是在原型对象上</p><blockquote><p>Object.getOwnPropertyDescriptor()方法只对实例属性有效。要取得原型属性的描述符，需要在原型对象上调用该方法。</p></blockquote><h5 id="原型和in操作符" tabindex="-1"><a class="header-anchor" href="#原型和in操作符" aria-hidden="true">#</a> 原型和in操作符</h5><ol><li><p>单独使用</p><p>在单独使用时，<code>in</code>操作符会在可<code>以通过对象访问指定属性时返回true，无论该属性是在实例上还是在原型上</code></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;name&#39;</span> <span class="token keyword">in</span> person1<span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>在for-in循环中使用</p><p>通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。遮蔽原型中不可枚举属性的实例属性也会在for-in循环中返回，因为默认情况下开发者定义的属性都是可枚举的。</p><p><code>Object.keys()</code>可以获得对象上所有可枚举的实例属性。</p><p><code>Object.getOwnPropertyNames()</code>会返回所有实例属性，不论是否可枚举。</p><p><code>Object.getOwnPropertySymbols()</code>:ES6新增，因为以符号为键的属性没有名称的概念。只针对符号而已。</p></li></ol><h5 id="属性枚举顺序" tabindex="-1"><a class="header-anchor" href="#属性枚举顺序" aria-hidden="true">#</a> 属性枚举顺序</h5><p>for-in循环、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnProperty-Symbols()以及Object.assign()在属性枚举顺序方面有很大区别。</p><p><strong>for-in循环和Object.keys()的枚举顺序是不确定的</strong>，取决于JavaScript引擎，可能因浏览器而异。</p><p>**Object.getOwnPropertyNames()、Object.getOwnProperty-Symbols()以及Object.assign()**的枚举顺序是确定性的。先以升序枚举数键值，然后以插入顺序枚举字符串和符号键。</p><h5 id="对象迭代" tabindex="-1"><a class="header-anchor" href="#对象迭代" aria-hidden="true">#</a> 对象迭代</h5><p>ES2017新增了两个静态方法 <code>Object.entries()和Object.values()</code>，执行对象的浅复制。符号属性会被忽略</p><blockquote><p>非字符串属性会被转换为字符串输出</p></blockquote><h6 id="其他原型语法" tabindex="-1"><a class="header-anchor" href="#其他原型语法" aria-hidden="true">#</a> 其他原型语法</h6><p>设置原型属性和方法会将<code>prototype</code>重写一遍，可使用下面的方法，但是会带来一个问题<code>Person.prototype</code>的<code>constructor</code>不会再指向<code>Person</code></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token class-name">Person3</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1. 可以重写 constructor,但这种方法会将原本不可枚举的constructor属性设置为可枚举，可以使用Object.defineProperty 方法定义</span>
    <span class="token comment">// constructor: Person,</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;1&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    <span class="token literal-property property">job</span><span class="token operator">:</span> <span class="token string">&#39;test&#39;</span><span class="token punctuation">,</span>
    <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> friends <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>friends<span class="token punctuation">.</span><span class="token class-name">__proto__</span><span class="token punctuation">.</span>constructor<span class="token punctuation">)</span> <span class="token comment">// [Function Object]</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>friends<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span> <span class="token comment">// [Function Object]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>friends<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span> <span class="token comment">// true</span>


<span class="token comment">// 2. Object.defineProperty添加constructor</span>
Object<span class="token punctuation">.</span><span class="token function">defineproperty</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">&#39;constructor&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token literal-property property">value</span><span class="token operator">:</span> Person
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6 id="原型的动态性" tabindex="-1"><a class="header-anchor" href="#原型的动态性" aria-hidden="true">#</a> 原型的动态性</h6><p>因为从原型上搜索值的过程是动态的，即使实例在修改原型之前就已经存在，任何时候对原型对象所做的修改也会在实例上反映出来。</p><p><strong>虽然随时能给原型添加属性和方法，并能够立即反映在所有对象实例上，但这跟重写整个原型是两回事</strong>。**实例的[[Prototype]]指针是在调用构造函数时自动赋值的，这个指针即使把原型修改为不同的对象也不会变。**重写整个原型会切断最初原型与构造函数的联系，<strong>但实例引用的仍然是最初的原型</strong>。记住，<strong>实例只有指向原型的指针，没有指向构造函数的指针</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> friends <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;1&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

friends<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 错误</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原因如下图：</p><p><img src="https://raw.githubusercontent.com/diandianyezi/typora-images/master/img/202205241132505.png" alt="image-20220524113243420"></p><p>重写构造函数上的原型之后再创建的实例才会引用新的原型。</p><h6 id="原生对象原型" tabindex="-1"><a class="header-anchor" href="#原生对象原型" aria-hidden="true">#</a> 原生对象原型</h6><blockquote><p>并不推荐在产品环境中修改原生对象原型。</p></blockquote><h6 id="原型的问题" tabindex="-1"><a class="header-anchor" href="#原型的问题" aria-hidden="true">#</a> 原型的问题</h6><ol><li>弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同属性的值；</li><li>共享特性</li></ol><p>原型上所有属性是在实例间共享的，这对函数来说比较合适。包含原始值的属性也还好。<strong>真正的问题来自包含原始引用值的属性。</strong></p><h2 id="继承" tabindex="-1"><a class="header-anchor" href="#继承" aria-hidden="true">#</a> 继承</h2><p><strong>实现继承</strong> 是<strong>ECMAScript</strong>唯一支持的继承方式，而这主要是通过<strong>原型链</strong>实现的。</p><h3 id="原型链-1" tabindex="-1"><a class="header-anchor" href="#原型链-1" aria-hidden="true">#</a> 原型链</h3><p>基本思想：通过原型继承多个引用类型的属性和方法。</p><p>实现原型链：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  tis<span class="token punctuation">.</span>property <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>

<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSuperValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>property
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>subProperty <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>

<span class="token comment">// 继承自SuperType  实现继承的关键</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSubValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subProperty
<span class="token punctuation">}</span>

<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token function">getSuperValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/diandianyezi/typora-images/master/img/202205241156591.png" alt="image-20220524115631506"></p><h4 id="默认原型" tabindex="-1"><a class="header-anchor" href="#默认原型" aria-hidden="true">#</a> 默认原型</h4><p>任何函数的默认原型都是一个Object实例，</p><p><img src="https://raw.githubusercontent.com/diandianyezi/typora-images/master/img/202205241330109.png" alt="image-20220524133027020"></p><h4 id="原型与继承关系" tabindex="-1"><a class="header-anchor" href="#原型与继承关系" aria-hidden="true">#</a> 原型与继承关系</h4><p>原型与实例的关系可以通过两种当时确定：</p><ul><li><code>instanceof</code> 操作符：实例的原型链中出现过相应的构造函数，返回true</li><li><code>isProtootypeOf()</code> 方法：原型链中的每个原型都可以调用这个方法，只要原型链中包含这个原型，则返回true</li></ul><h4 id="关于方法" tabindex="-1"><a class="header-anchor" href="#关于方法" aria-hidden="true">#</a> 关于方法</h4><p>子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为此，<strong>这些方法必须在原型赋值之后再添加到原型上</strong></p><h4 id="原型链的问题" tabindex="-1"><a class="header-anchor" href="#原型链的问题" aria-hidden="true">#</a> 原型链的问题</h4><ul><li>在原型中包含引用值的时候，会在所有实例间共享</li><li>子类型在实例化时不能给父类型的构造函数传参</li></ul><p>所以基于上述原因，原型链并不会被单独使用。</p><h3 id="盗用构造函数" tabindex="-1"><a class="header-anchor" href="#盗用构造函数" aria-hidden="true">#</a> 盗用构造函数</h3><p>基于上述原型链的问题，基本思路：在子类构造函数中调用父类构造函数</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;red&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;green&#39;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 继承SuperType</span>
  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
instance1<span class="token punctuation">.</span>color<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&#39;black&#39;</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="传递参数" tabindex="-1"><a class="header-anchor" href="#传递参数" aria-hidden="true">#</a> 传递参数</h4><p>盗用构造函数的一个优点就是可以<strong>在子类构造函数中向父类构造函数传参</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">&#39;Ni&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">29</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> insta <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="盗用构造函数问题" tabindex="-1"><a class="header-anchor" href="#盗用构造函数问题" aria-hidden="true">#</a> 盗用构造函数问题</h4><p>缺点：也就是使用构造函数模式自定义类型的问题：必须在构造函数中定义方法，因此函数不能重用。子类也不能访问父类原型上定义的方法。所以也不能单独使用。</p><h3 id="组合继承" tabindex="-1"><a class="header-anchor" href="#组合继承" aria-hidden="true">#</a> 组合继承</h3><p>基本思路：使用原型链继承原型上的属性和方法，而听过盗用构造函数继承实例属性。既可以把方法定义在原型上实现重用，又可以让每个实例都可以有自己的属性。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// example</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>组合继承弥补了原型链和盗用构造函数的不足，是JavaScript中使用最多的继承模式。而且组合继承也保留了instanceof操作符和isPrototypeOf()方法识别合成对象的能力。</p><h3 id="原型式继承" tabindex="-1"><a class="header-anchor" href="#原型式继承" aria-hidden="true">#</a> 原型式继承</h3><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Object.create()</code></p><p>原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。但要记住，属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的。</p><h3 id="寄生式继承" tabindex="-1"><a class="header-anchor" href="#寄生式继承" aria-hidden="true">#</a> 寄生式继承</h3><p>思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。基本的寄生继承模式如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">createAnother</span><span class="token punctuation">(</span><span class="token parameter">original</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> clone <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span>
  clone<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> clone
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>寄生式继承同样<strong>适合主要关注对象，而不在乎类型和构造函数的场景</strong>。object()函数不是寄生式继承所必需的，任何返回新对象的函数都可以在这里使用。</p><blockquote><p>通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似</p></blockquote><h3 id="寄生式组合继承" tabindex="-1"><a class="header-anchor" href="#寄生式组合继承" aria-hidden="true">#</a> 寄生式组合继承</h3><p>组合继承的问题主要是：父类构造函数会被调用两次</p><p>解决方法：寄生式组合继承，通过盗用构造函数继承属性，但是用混合式原型链继承方法。基本思路是不通过调用父类构造函数给子类原型复制，而是取得父类原型的一个副本。使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span><span class="token parameter">subType<span class="token punctuation">,</span> superType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> prototype <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token keyword">super</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// 创建对象</span>
  prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> subType <span class="token comment">// 增强对象</span>
  subType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype <span class="token comment">// 赋值对象</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;red&#39;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function-variable function">SubType</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
<span class="token punctuation">}</span>

<span class="token function">inheritPrototype</span><span class="token punctuation">(</span>SubType<span class="token punctuation">,</span> SuperType<span class="token punctuation">)</span>

<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayAge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><!----><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 1092923594@qq.com">zhangting</span><!--]--><!--]--></div></div></footer><!----><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/">主题配置：VuePress Theme Hope</a></div><div class="copyright">Copyright © 2023 Yezi</div></footer></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/assets/app-74f1da39.js" defer></script>
  </body>
</html>
