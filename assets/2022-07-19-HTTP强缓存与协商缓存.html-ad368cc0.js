import{_ as o,W as t,X as c,Z as e,a1 as i,$ as n,a2 as d,C as r}from"./framework-609d4fec.js";const h={},l=d('<h3 id="http缓存" tabindex="-1"><a class="header-anchor" href="#http缓存" aria-hidden="true">#</a> HTTP缓存</h3><p>主要作用：资源获取更快，提升用户体验，减少网络传输，缓解服务端的压力。以下是缓存运作的整体流程图：</p><p><img src="https://raw.githubusercontent.com/diandianyezi/typora-images/master/img/image-20220728095314113.png" alt="image-20220728095314113"></p><h3 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h3><p>强缓存和协商缓存</p><h3 id="强缓存" tabindex="-1"><a class="header-anchor" href="#强缓存" aria-hidden="true">#</a> 强缓存</h3><p>主要使用 <code>Expires</code> 和 <code>Cache-Control</code>两个头字段，两者同时存在时， <code>Cache-Control</code>优先级更高。当命中强缓存时，客户端不会再请求，直接从缓存中读取内容，并返回HTTP状态码200。</p><h4 id="基本原理" tabindex="-1"><a class="header-anchor" href="#基本原理" aria-hidden="true">#</a> 基本原理</h4><p>在浏览器加载资源的时候，首先会根据请求头的 <code>Expires</code> 和 <code>Cache-Control</code>判断是否<strong>命中强缓存策略</strong>，<strong>判断是否向远程服务器请求资源还是去本地获取缓存资源。</strong></p><p>在浏览器中，强缓存分为 <code>Expires</code> 和 <code>Cache-Control</code> 两种</p><h4 id="expires" tabindex="-1"><a class="header-anchor" href="#expires" aria-hidden="true">#</a> Expires</h4><blockquote><p>响应头，代表该资源的过期时间。是一个GMT格式的标准时间</p></blockquote><p>是 <code>Http1.0</code>的规范，用于<strong>表示资源的过期时间</strong>的 请求头字段，值是一个绝对时间，是由服务器返回的。</p><p>在浏览器第一个请求资源时，服务器端的<strong>响应头</strong>上会附上 <code>Expires</code>这个响应字段，当浏览器在=下一次请求这个资源时会根据上次的 <code>Expires</code>字段判断是否使用缓存资源（当请求时间小于服务端返回的到期时间，直接使用缓存数据）</p><blockquote><p><code>Expires</code> 是根据本地时间来判断的，假设客户端和服务端时间不同，会导致缓存命中误差</p></blockquote><h5 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点：</h5><ul><li>缓存期过后，不管文件有没有变化会再次请求服务器</li><li>缓存期时间是一个具体时间，依赖于客户端时间，如果时间不准确或者被改动，缓存也会随之受影响。</li></ul><hr><h4 id="cache-control" tabindex="-1"><a class="header-anchor" href="#cache-control" aria-hidden="true">#</a> Cache-control</h4>',19),s={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control",target:"_blank",rel:"noopener noreferrer"},p=d(`<blockquote><p>请求/响应头，缓存控制字段，精确控制缓存策略</p></blockquote><p><code>Http 1.1</code>规范，由于 <code>Expires</code>有个缺点，当客户端本地时间被修改时，浏览器会直接向服务器请求新的资源，为此，提出了 <code>Cache-Control</code>字段，优先级高于 <code>Expires</code>，值是相对时间。</p><h5 id="cache-control中常见的服务端响应值" tabindex="-1"><a class="header-anchor" href="#cache-control中常见的服务端响应值" aria-hidden="true">#</a> <code>Cache-Control</code>中常见的服务端响应值</h5><p>它们分别是：</p><table><thead><tr><th>属性值</th><th>值</th><th>备注</th></tr></thead><tbody><tr><td>max-age</td><td>3600</td><td>==多少秒内有效==，相对于请求的时间，例如值为3600，表示（当前时间+3600秒）内不与服务器请求新的数据资源</td></tr><tr><td>s-maxage</td><td></td><td>和 max-age一样，但这个是设定==代理服务器的缓存有效时间==，并只对public缓存有效，覆盖 max-age 和 Expires头。私有缓存会忽略它</td></tr><tr><td>private</td><td></td><td>内容只缓存到私有缓存中（仅客户端可以缓存，代理服务器不可缓存）。==默认值==</td></tr><tr><td>public</td><td></td><td>所有内容都将被缓存（客户端、代理服务端都可缓存）</td></tr><tr><td>no-store</td><td></td><td>不缓存任何数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</td></tr><tr><td>no-cache</td><td></td><td>不使用本地强缓存，需要使用协商缓存</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 可缓存性
Cache-control: no-cache
Cache-control: no-store
Cache-control: public
Cache-control: private

Cache-control: proxy-revalidate
Cache-Control: max-age=&lt;seconds&gt;
Cache-control: s-maxage=&lt;seconds&gt;
Cache-control: no-transform
Cache-control: must-revalidate
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="cache-control中常见的客户端参数" tabindex="-1"><a class="header-anchor" href="#cache-control中常见的客户端参数" aria-hidden="true">#</a> <code>Cache-Control</code>中常见的客户端参数</h5><ul><li>max-stale:5 表示客户端到代理服务器拿缓存的时候，即时代理缓存过期了也不要紧，只要过期时间在5秒内，还是可以从代理中获取。</li><li>min-fresh:5 表示代理缓存需要一定的新鲜度，不要等到缓存刚好到期再拿，一定要在到期前 5 秒之前的时间拿，否则拿不到。</li><li>only-if-cached 这个字段加上后表示客户端只会接受代理缓存，而不会接收源服务器的响应。如果代理缓存无效，则直接返回 504（Gateway Timeout）。</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 到期
Cache-Control: max-age=&lt;seconds&gt;
Cache-Control: max-stale[=&lt;seconds&gt;]
Cache-Control: min-fresh=&lt;seconds&gt;

Cache-control: no-cache
Cache-control: no-store
// 其他 
Cache-control: no-transform // 不能对资源进行转换或改变
Cache-control: only-if-cached // 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="pragma" tabindex="-1"><a class="header-anchor" href="#pragma" aria-hidden="true">#</a> Pragma</h3><p>只有一个属性值： <code>no-cache</code>，效果与 <code>Cache-Control</code>的no-cache一致，不使用强缓存，需要与服务器验证缓存是否有效， <code>Expires</code>、<code>Cache-Control</code>、 <code>Pragma</code>这三者中 <code>Pragma</code>优先级最高。</p><h3 id="协商缓存" tabindex="-1"><a class="header-anchor" href="#协商缓存" aria-hidden="true">#</a> 协商缓存</h3><p>主要有四个字段：两两配合使用</p><ul><li><code>If-Modified-Since</code> 和 <code>Last-Modified</code></li><li><code>Etag</code> 和 <code>If-None-Match</code></li></ul><p>当同时存在的时候会以<code>Etag</code> 和 <code>If-None-Match</code>为主。</p><p>命中协商缓存时，服务器返回304，让客户端直接从本地缓存里读取。</p><h4 id="if-modified-since" tabindex="-1"><a class="header-anchor" href="#if-modified-since" aria-hidden="true">#</a> <code>If-Modified-Since</code></h4><blockquote><p>请求头，资源最近的修改时间。由浏览器告诉服务器，其实为第一次访问服务器返回的<code>Last-Modified</code> 的值</p></blockquote><h4 id="last-modified" tabindex="-1"><a class="header-anchor" href="#last-modified" aria-hidden="true">#</a> <code>Last-Modified</code></h4><blockquote><p>响应头，资源最近的修改时间，服务器告诉浏览器</p></blockquote><h4 id="etag" tabindex="-1"><a class="header-anchor" href="#etag" aria-hidden="true">#</a> <code>Etag</code></h4><blockquote><p>响应头，资源标识，由服务器告诉浏览器。</p></blockquote><h4 id="if-none-match" tabindex="-1"><a class="header-anchor" href="#if-none-match" aria-hidden="true">#</a> <code>If-None-Match</code></h4><blockquote><p>请求头，缓存资源标识，由浏览器告诉服务器。其实为第一次访问服务端返回的<code>Etag</code>的值。</p></blockquote><h4 id="if-modified-since-和-last-modified" tabindex="-1"><a class="header-anchor" href="#if-modified-since-和-last-modified" aria-hidden="true">#</a> <code>If-Modified-Since</code> 和 <code>Last-Modified</code></h4><p>当客户端第一次请求服务器的时候，服务端会返回 <code>Last-Modified</code>响应头，该字段为一个标准时间。当客户端请求服务器时，会带上 <code>If-Modified-Since</code>请求头字段（为第一次服务器返回的<code>Last-Modified</code>的值）。服务器接收到请求后会比较两个值是否一样，一样则返回 304，让客户端读取缓存，不一样就会返回新文件，并更新 <code>Last-Modified</code> 字段。</p><h5 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点：</h5><ul><li>缓存有效时，不会返回文件给客户端，直接返回304。大大节省了流量和带宽及服务器压力。</li></ul><h5 id="缺点-1" tabindex="-1"><a class="header-anchor" href="#缺点-1" aria-hidden="true">#</a> 缺点：</h5><ul><li><code>Last-Modified</code>只能精确到秒。如果在同一秒既修改了文件又获取文件，客户端获取不到最新文件。</li></ul><h4 id="etag-和-if-none-match" tabindex="-1"><a class="header-anchor" href="#etag-和-if-none-match" aria-hidden="true">#</a> <code>Etag</code> 和 <code>If-None-Match</code></h4><p>为了解决文件修改时间只能精确到秒带来的问题，我们引入 Etag 响应头。Etag 是由文件修改时间与文件大小计算而成，只有当文件文件内容或修改时间变了Etag的值才会发生变化。</p><p>当客户端第一次请求服务器的时候，服务端会返回一个Etag响应头。客户端请求服务器的时候会带上If-None-Match请求头字段，该字段的值就是服务器返回的Etag的值。服务器接收到请求后会比较这两个值是否一样，一样就返回304，让客户端从缓存中读取，不一样就会返回新文件给客户端并更新Etag响应头字段的值。</p><h5 id="优点-1" tabindex="-1"><a class="header-anchor" href="#优点-1" aria-hidden="true">#</a> 优点：</h5><ul><li>解决了一秒内修改并读取的问题</li></ul><p>参考文章：</p><p>https://juejin.cn/post/7101942484543995934</p><p>https://mp.weixin.qq.com/s/IFjmWvxFXc4jCKp3o6to_g</p><p>https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching</p><p>实践demo： 参考自：https://juejin.cn/post/7065895592613904392 https://github.com/diandianyezi/cache-demo</p>`,40);function u(m,f){const a=r("ExternalLinkIcon");return t(),c("div",null,[l,e("p",null,[e("a",s,[i("MDN Cache-Control"),n(a)])]),p])}const g=o(h,[["render",u],["__file","2022-07-19-HTTP强缓存与协商缓存.html.vue"]]);export{g as default};
