import{_ as e,W as i,X as l,a2 as a}from"./framework-609d4fec.js";const p={},r=a('<h2 id="什么是首屏加载时间" tabindex="-1"><a class="header-anchor" href="#什么是首屏加载时间" aria-hidden="true">#</a> 什么是首屏加载时间？</h2><p>浏览器从相应用户输入网址到首屏内容渲染完成的时间。整个网页不需要全部加载完成，视口内的内容显示即可。</p><h2 id="如何计算首屏加载时间" tabindex="-1"><a class="header-anchor" href="#如何计算首屏加载时间" aria-hidden="true">#</a> 如何计算首屏加载时间？</h2><p>在Chrome的控制台中的Load就是</p><h2 id="首屏加载时间慢的原因" tabindex="-1"><a class="header-anchor" href="#首屏加载时间慢的原因" aria-hidden="true">#</a> 首屏加载时间慢的原因？</h2><ol><li>网络延时</li><li>资源文件体积过大</li><li>资源重复请求加载</li><li>加载脚本过程中，渲染堵塞。</li></ol><p>针对以上2，3原因，有以下解决方案：</p><ol><li>减少入口文件体积</li></ol><ul><li><p>路由懒加载</p><p>以函数形式加载路由，可以将各自的路由文件打包，在访问对应路由的时候再加载路由文件。</p></li><li><p>静态资源本地缓存</p><p>前端合理使用localStorage，sessionStorage等缓存方式。</p><p>采用HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头。</p><p>采用Service Worker离线缓存</p></li><li><p>按需加载</p><p>像ant-design-vue，可以使用babel插件按需加载</p></li><li><p>避免组件文件重复打包</p></li><li><p>使用SSR（服务端渲染），即组件和页面通过服务器生成html字符串，再发送到浏览器。vue可以使用Nuxt.js实现服务端渲染</p></li><li><p>图片压缩</p></li><li><p>防抖节流</p><p>有一些请求可以不用频繁请求，减少服务器压力</p></li></ul>',9),t=[r];function o(d,h){return i(),l("div",null,t)}const s=e(p,[["render",o],["__file","2022-04-12-首屏加载时间.html.vue"]]);export{s as default};
