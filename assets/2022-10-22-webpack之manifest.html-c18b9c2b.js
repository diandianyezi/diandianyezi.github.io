import{_ as n,W as i,X as r,Z as t,a1 as e,$ as o,a2 as s,C as c}from"./framework-609d4fec.js";const l={},d=s('<h1 id="manifest" tabindex="-1"><a class="header-anchor" href="#manifest" aria-hidden="true">#</a> manifest</h1><p>在使用webpack构建的典型应用程序或站点中，有三种主要的代码类型：</p><ul><li>编写的源码；</li><li>依赖的第三方的libary或vendor代码；</li><li>webpack的runtime和manifest，管理所有模块的交互。</li></ul><h2 id="runtime" tabindex="-1"><a class="header-anchor" href="#runtime" aria-hidden="true">#</a> runtime</h2><p>runtime，以及伴随的manifest数据，主要是指：在浏览器运行过程中，webpack用来连接模块化应用程序所需的所有代码。它包含：在模块交互时，连接模块所需的加载和解析逻辑。包括：已经加载到浏览器中的连接模块逻辑，以及尚未加载模块的延迟加载逻辑。</p><h2 id="manifest-1" tabindex="-1"><a class="header-anchor" href="#manifest-1" aria-hidden="true">#</a> manifest</h2><p>管理所有模块之间的交互。</p>',7),_=t("strong",null,"compiler",-1),m={href:"https://webpack.docschina.org/api/module-methods",target:"_blank",rel:"noopener noreferrer"},h=t("code",null,"import",-1),u=t("code",null,"require",-1),f=t("code",null,"__webpack_require__",-1),p=t("strong",null,"模块标识符(module identifier)",-1);function b(k,x){const a=c("ExternalLinkIcon");return i(),r("div",null,[d,t("p",null,[e("当 "),_,e(' 开始执行、解析和映射应用程序时，它会保留所有模块的详细要点。这个数据集合称为 "manifest"，当完成打包并发送到浏览器时，runtime 会通过 manifest 来解析和加载模块。无论你选择哪种 '),t("a",m,[e("模块语法"),o(a)]),e("，那些 "),h,e(" 或 "),u,e(" 语句现在都已经转换为 "),f,e(" 方法，此方法指向"),p,e("。通过使用 manifest 中的数据，runtime 将能够检索这些标识符，找出每个标识符背后对应的模块。")])])}const g=n(l,[["render",b],["__file","2022-10-22-webpack之manifest.html.vue"]]);export{g as default};
