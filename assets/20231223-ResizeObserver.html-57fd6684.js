const e=JSON.parse('{"key":"v-5e4e9a15","path":"/article/20231223-ResizeObserver.html","title":"学习Resize Observer API","lang":"zh-CN","frontmatter":{"title":"学习Resize Observer API","date":"2023-09-09T00:00:00.000Z","sidebar":"heading","breadcrumb":true,"lastUpdated":true,"contributors":true,"editLink":false,"category":["JavaScript"],"tag":["API"],"description":"Resize Observer API 在最近的需求开发中，新接触了这个API，日常记录一下。 这是一种无侵入的观察方式，可以在完全不影响目标元素业务逻辑的同时，嵌入需要响应变化的功能逻辑，例如发送埋点数据。减轻了开发者的心智负担和维护成本。 ResizeObserver ResizeObserver接口监视Element内容盒或边框盒或者SVGElement边界尺寸的变化。 ResizeObserver避免了通过回调函数调整大小时，通常创建的无限回调循环和循环依赖项。它只能通过在后续的帧中处理DOM中更深层次的元素来做到这一点。如果它的实现遵循规范，则应在绘制前和布局后调用 resize 事件。","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-v2-demo.netlify.app/article/20231223-ResizeObserver.html"}],["meta",{"property":"og:site_name","content":"Yezi’s Blog"}],["meta",{"property":"og:title","content":"学习Resize Observer API"}],["meta",{"property":"og:description","content":"Resize Observer API 在最近的需求开发中，新接触了这个API，日常记录一下。 这是一种无侵入的观察方式，可以在完全不影响目标元素业务逻辑的同时，嵌入需要响应变化的功能逻辑，例如发送埋点数据。减轻了开发者的心智负担和维护成本。 ResizeObserver ResizeObserver接口监视Element内容盒或边框盒或者SVGElement边界尺寸的变化。 ResizeObserver避免了通过回调函数调整大小时，通常创建的无限回调循环和循环依赖项。它只能通过在后续的帧中处理DOM中更深层次的元素来做到这一点。如果它的实现遵循规范，则应在绘制前和布局后调用 resize 事件。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-23T13:20:27.000Z"}],["meta",{"property":"article:tag","content":"API"}],["meta",{"property":"article:published_time","content":"2023-09-09T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-23T13:20:27.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"学习Resize Observer API\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-09-09T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-23T13:20:27.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"ResizeObserver","slug":"resizeobserver","link":"#resizeobserver","children":[{"level":3,"title":"构造函数","slug":"构造函数","link":"#构造函数","children":[]},{"level":3,"title":"属性","slug":"属性","link":"#属性","children":[]},{"level":3,"title":"方法","slug":"方法","link":"#方法","children":[]},{"level":3,"title":"代码示例","slug":"代码示例","link":"#代码示例","children":[]},{"level":3,"title":"兼容性","slug":"兼容性","link":"#兼容性","children":[]}]},{"level":2,"title":"ResizeObserverEntry","slug":"resizeobserverentry","link":"#resizeobserverentry","children":[{"level":3,"title":"属性","slug":"属性-1","link":"#属性-1","children":[]}]}],"git":{"createdTime":1703322728000,"updatedTime":1703337627000,"contributors":[{"name":"zhangting","email":"1092923594@qq.com","commits":2}]},"readingTime":{"minutes":2.87,"words":862},"filePathRelative":"article/20231223-ResizeObserver.md","localizedDate":"2023年9月9日","excerpt":"<h1> Resize Observer API</h1>\\n<p>在最近的需求开发中，新接触了这个API，日常记录一下。</p>\\n<p>这是一种无侵入的观察方式，可以在完全不影响目标元素业务逻辑的同时，嵌入需要响应变化的功能逻辑，例如发送埋点数据。减轻了开发者的心智负担和维护成本。</p>\\n<h2> ResizeObserver</h2>\\n<p><code>ResizeObserver</code>接口监视<code>Element</code>内容盒或边框盒或者<code>SVGElement</code>边界尺寸的变化。</p>\\n<p><code>ResizeObserver</code>避免了通过回调函数调整大小时，通常创建的无限回调循环和循环依赖项。它只能通过在后续的帧中处理DOM中更深层次的元素来做到这一点。如果它的实现遵循规范，则应在绘制前和布局后调用 resize 事件。</p>","autoDesc":true}');export{e as data};
