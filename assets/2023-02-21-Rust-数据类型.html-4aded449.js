import{_ as n,W as a,X as s,a2 as e}from"./framework-609d4fec.js";const p={},t=e(`<h1 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型" aria-hidden="true">#</a> 数据类型</h1><p>两种不同的数据类型子集：标量类型 scalar 和 复合类型 compound</p><h2 id="标量类型" tabindex="-1"><a class="header-anchor" href="#标量类型" aria-hidden="true">#</a> 标量类型</h2><p>标量类型是单个值类型的统称。Rust内置了4种基础的标量类型：整数、浮点数、布尔值及字符。</p><h3 id="整型" tabindex="-1"><a class="header-anchor" href="#整型" aria-hidden="true">#</a> 整型</h3><p>有符号类型<code>signed</code>（可以存储正数或负数） 无符号类型<code>usigned</code>只能存储正数</p><p>按存储空间来说，划分为1字节 2字节 4字节 8字节 16字节，1字节= 8位</p><p>整型的长度还可以是<code>arch</code>。<code>arch</code>是由CPU架构决定的大小的整数类型，大小为<code>arch</code>的整数在x86机器上为32位，在x64的机器上为64位。</p><p>整型取值范围：</p><p>有符号能存储的最小值为 <code>-(2 ^(n-1))</code>，能够存储的最大值为 <code>2 ^ (n-1) - 1</code></p><p>无符号整型能够存储的最小值为0，能够存储的最大值为<code>2^n - 1</code></p><p>​</p><h3 id="浮点型" tabindex="-1"><a class="header-anchor" href="#浮点型" aria-hidden="true">#</a> 浮点型</h3><p>按照存储大小，分为f32和f64，其中f64为默认的浮点类型。</p><ul><li>f32为单精度浮点型</li><li>f64为双精度浮点型，默认为双精度浮点型</li></ul><blockquote><p>Rust中不能将0.0赋值给任已一个整型，也不能将0赋值给任一个浮点型。</p></blockquote><h6 id="下划线" tabindex="-1"><a class="header-anchor" href="#下划线" aria-hidden="true">#</a> _ 下划线</h6><p>当数值很大的时候，使用_，使得数字的可读性更好</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">let</span> price <span class="token operator">=</span> <span class="token number">1_000_000</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> price2 <span class="token operator">=</span> <span class="token number">1_000_000.2222</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="布尔型和字符型" tabindex="-1"><a class="header-anchor" href="#布尔型和字符型" aria-hidden="true">#</a> 布尔型和字符型</h3><ul><li>char类型：占4字节，字符类型，是字符串的基本组成，单个字符或字，使用<code>UTF-8</code>作为底层编码而不是常见的<code>ASCII</code>作为底层编码，包含数字、字母、Unicode和其他特殊字符，使用单引号指定。</li><li>布尔类型</li></ul><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">let</span> checked<span class="token punctuation">:</span>boolean <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> ch<span class="token punctuation">:</span><span class="token keyword">char</span> <span class="token operator">=</span> <span class="token char">&#39;Y&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="复合类型" tabindex="-1"><a class="header-anchor" href="#复合类型" aria-hidden="true">#</a> 复合类型</h2><p>可以将多个不同类型的值组合为一个类型。Rust内置了两种基础的复合类型：元祖tuple 和数组 array。</p><h3 id="元组类型" tabindex="-1"><a class="header-anchor" href="#元组类型" aria-hidden="true">#</a> 元组类型</h3><p>可以将其他不同类型的多个值组合进一个复合类型中。元组还拥有一个固定的长度：你无法在声明结束后增加或减少其中的元素数量。</p><p>元组每个位置的值都有一个类型，这些类型不需要是相同的。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> tup <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">6.6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span> <span class="token operator">=</span> tup<span class="token punctuation">;</span> <span class="token comment">// 解构元组</span>
  <span class="token comment">// 还可以使用.访问元组里的值</span>
  <span class="token comment">// tup.0  tup.1  tup.2</span>
  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;x is {},y is {},z is {}&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="数组类型" tabindex="-1"><a class="header-anchor" href="#数组类型" aria-hidden="true">#</a> 数组类型</h3><p>与元组不同的是，数组的每个元素必须是相同的类型。Rust中的数组拥有固定的长度，一旦声明就不能随意更改大小。Rust也提供了更加灵活的动态数据<code>vector</code>，动态数据是一个类似于数组的几个结构，但它允许用户自由地调整数组长度。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">let</span> arr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// </span>
<span class="token keyword">let</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 声明了含有相同元素3的长度为5的数组。</span>

<span class="token comment">// 数组访问</span>
<span class="token keyword">let</span> first <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="非法的数组元素访问" tabindex="-1"><a class="header-anchor" href="#非法的数组元素访问" aria-hidden="true">#</a> 非法的数组元素访问</h4><p>可以顺利通过编译，但会在运行时因为错误而崩溃退出。</p><p>每次通过索引来访问一个元素时，Rust都会检查这个索引是否小于当前数组的长度。假如索引超出了当前数组的长度，Rust就会发生panic。</p>`,34),c=[t];function o(i,l){return a(),s("div",null,c)}const r=n(p,[["render",o],["__file","2023-02-21-Rust-数据类型.html.vue"]]);export{r as default};
