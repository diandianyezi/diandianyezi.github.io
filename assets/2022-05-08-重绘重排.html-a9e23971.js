import{_ as i,W as l,X as e,a2 as a}from"./framework-609d4fec.js";const t={},r=a('<h2 id="重绘重排" tabindex="-1"><a class="header-anchor" href="#重绘重排" aria-hidden="true">#</a> 重绘重排</h2><h3 id="重绘-repaint" tabindex="-1"><a class="header-anchor" href="#重绘-repaint" aria-hidden="true">#</a> 重绘 repaint</h3><p>在不改变文档布局的情况下，文档元素发生的例如背景颜色等外观的行为可称为重绘。</p><h3 id="重排-reflow" tabindex="-1"><a class="header-anchor" href="#重排-reflow" aria-hidden="true">#</a> 重排 reflow</h3><p>也称为回流</p><p>引起dom树结构发生变化，导致渲染树的重新渲染</p><p>回流一定会导致重绘，但重绘不一定会导致回流</p><h3 id="常见的场景" tabindex="-1"><a class="header-anchor" href="#常见的场景" aria-hidden="true">#</a> 常见的场景：</h3><h4 id="回流常见于元素的尺寸-布局-隐藏等dom结构发生变化的情况" tabindex="-1"><a class="header-anchor" href="#回流常见于元素的尺寸-布局-隐藏等dom结构发生变化的情况" aria-hidden="true">#</a> 回流常见于元素的尺寸，布局，隐藏等Dom结构发生变化的情况，</h4><ul><li>添加或者删除可见的dom元素</li><li>元素位置改变</li><li>元素尺寸改变（边距、填充、边框、高度和宽度）</li><li>内容改变（内容物引起的元素大小发生变化）</li><li>页面渲染发生变化</li><li>浏览器尺寸改变</li><li>计算元素的偏移量属性</li></ul><h4 id="重绘常见于元素的颜色的样式发生改变的情况" tabindex="-1"><a class="header-anchor" href="#重绘常见于元素的颜色的样式发生改变的情况" aria-hidden="true">#</a> 重绘常见于元素的颜色的样式发生改变的情况</h4><ul><li>改变字体</li><li>增加或者移除样式表</li><li>内容变化</li><li>激活CSS伪类</li><li>设置style属性值</li><li>计算offseWidth和offsetHeight属性</li></ul><h3 id="如何优化浏览器的回流与重绘" tabindex="-1"><a class="header-anchor" href="#如何优化浏览器的回流与重绘" aria-hidden="true">#</a> 如何优化浏览器的回流与重绘</h3><ol><li><p>将那些改变样式的操作集合在一起，直接改变className或者cssText</p></li><li><p>让要操作的元素进行离线处理，处理完事以后再一起更新</p><ul><li>使用DocumentFragment进行缓存操作，引发一次回流和重绘</li><li>使用display:none，只引发两次回流和重绘。</li><li>使用cloneNode和replaceChild技术，引发一次回流和重绘（将原始元素拷贝到一个脱离文档流的节点中，修改节点之后，再替换原始元素）</li></ul></li><li><p>不要经常访问会引起浏览器flush队列的属性，非要高频访问的话建议缓存到变量</p></li><li><p>将需要多次重排的元素，postion属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素最好设置为绝对定位。</p></li><li><p>尽量不要使用表格布局，如果没有定宽，表格一列的宽度由最宽的一列决定，那么很可能在最后一行的宽度超出之前的列宽，引起整体回流造成table可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。</p></li><li><p>避免触发同步布局事件</p><p>现代浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！<strong>当你获取布局信息的操作的时候，会强制队列刷新</strong>，比如当你访问以下属性或者使用以下方法：</p><ul><li><p>offsetTop、offsetLeft、offsetWidth、offsetHeight</p></li><li><p>scrollTop、scrollLeft、scrollWidth、scrollHeight</p></li><li><p>clientTop、clientLeft、clientWidth、clientHeight</p></li><li><p>getComputedStyle()</p></li><li><p>getBoundingClientRect</p></li></ul></li><li><p>css3硬件加速，使用部分css3属性不会引起页面的回流与重绘或者造成的影响比较小</p></li></ol><h3 id="浏览器渲染的过程" tabindex="-1"><a class="header-anchor" href="#浏览器渲染的过程" aria-hidden="true">#</a> 浏览器渲染的过程</h3><p>渲染过程大致如下</p><ol><li>解析HTM，生成DOM树，解析CSS，生成CSSOM树；</li><li>将DOM树和CSSOM树结合，生成渲染树</li><li>回流Layout：根据生成的渲染树，进行回流得到节点信息（位置，大小）</li><li>重绘 Painting：根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li><li>Display：将像素发送给GPU，展示在页面上</li></ol><p>生成渲染树</p><ol><li>从DOM树的根节点开始遍历每个可见节点</li><li>对于每个可见的节点，找到CSSOM树种对应的规则，并应用它们。</li><li>根据每个可见节点以及其对应的样式，组合生成渲染</li></ol>',19),h=[r];function o(d,n){return l(),e("div",null,h)}const p=i(t,[["render",o],["__file","2022-05-08-重绘重排.html.vue"]]);export{p as default};
