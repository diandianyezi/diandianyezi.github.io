import{_ as a,W as e,X as h,a2 as r}from"./framework-609d4fec.js";const d={},i=r('<h1 id="贪心算法" tabindex="-1"><a class="header-anchor" href="#贪心算法" aria-hidden="true">#</a> 贪心算法</h1><p>(greeedy algorithm)</p><p>在问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做的是在某种意义上的局部最优解。</p><p>贪心算法并不保证会得到最优解，但在某些问题上贪心算法的解就是最优解。</p><h3 id="适用范围" tabindex="-1"><a class="header-anchor" href="#适用范围" aria-hidden="true">#</a> 适用范围</h3><p>在最优子结构问题中尤为有效。最优子结构的意思是问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。</p><h3 id="证明" tabindex="-1"><a class="header-anchor" href="#证明" aria-hidden="true">#</a> 证明</h3><p>贪心有两种证明方法：反证法和归纳法；</p><ol><li>如果交换方案中任意两个元素/相邻的两个元素后，答案不会变得更好，name可以推定目前的解已经是最优解了；</li><li>归纳法：先算得出边界情况的最优解F~1~，然后再证明每个n，F~n+1~都可以由F~n~推导得出结果。</li><li></li></ol><h2 id="经典示例" tabindex="-1"><a class="header-anchor" href="#经典示例" aria-hidden="true">#</a> 经典示例</h2><h3 id="找零问题" tabindex="-1"><a class="header-anchor" href="#找零问题" aria-hidden="true">#</a> 找零问题</h3><h3 id="背包问题" tabindex="-1"><a class="header-anchor" href="#背包问题" aria-hidden="true">#</a> 背包问题</h3><p>又分为0-1背包问题和分数背包问题</p><h4 id="_0-1背包问题" tabindex="-1"><a class="header-anchor" href="#_0-1背包问题" aria-hidden="true">#</a> 0-1背包问题</h4><h4 id="分数背包问题" tabindex="-1"><a class="header-anchor" href="#分数背包问题" aria-hidden="true">#</a> 分数背包问题</h4>',15),n=[i];function t(c,s){return e(),h("div",null,n)}const o=a(d,[["render",t],["__file","贪心算法.html.vue"]]);export{o as default};
