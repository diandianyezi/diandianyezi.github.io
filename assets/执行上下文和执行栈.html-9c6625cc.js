import{_ as e,W as a,X as d,a2 as o}from"./framework-609d4fec.js";const r={},i=o('<h1 id="执行上下文和执行栈" tabindex="-1"><a class="header-anchor" href="#执行上下文和执行栈" aria-hidden="true">#</a> 执行上下文和执行栈</h1><h2 id="执行上下文" tabindex="-1"><a class="header-anchor" href="#执行上下文" aria-hidden="true">#</a> 执行上下文</h2><h3 id="什么是执行上下文" tabindex="-1"><a class="header-anchor" href="#什么是执行上下文" aria-hidden="true">#</a> 什么是执行上下文？</h3><p>JS代码都是在执行上下文中运行的</p><p>执行上下文：指当前执行环境中的变量、函数声明、作用域链、<code>this</code>等信息</p><blockquote><p>执行上下文是当前JavaScript代码被解析和执行时所在环境的抽象概念。</p></blockquote><h3 id="执行上下文生命周期" tabindex="-1"><a class="header-anchor" href="#执行上下文生命周期" aria-hidden="true">#</a> 执行上下文生命周期</h3><p>分为创建阶段和执行阶段</p><ul><li>创建阶段：生成变量对象、建立作用域链、确定<code>this</code>的指向；</li><li>执行阶段：变量赋值、函数的引用、执行其他代码。</li></ul><p><img src="https://raw.githubusercontent.com/diandianyezi/typora-images/master/img/image-20230113161848651.png" alt="image-20230113161848651"></p><h4 id="创建阶段" tabindex="-1"><a class="header-anchor" href="#创建阶段" aria-hidden="true">#</a> 创建阶段</h4><h5 id="变量对象" tabindex="-1"><a class="header-anchor" href="#变量对象" aria-hidden="true">#</a> 变量对象</h5><p>变量对象是与执行上下文相关的数据作用域，存储了上下文中定义的变量和函数声明。变量对象是一个抽象概念，全局变量会作为该对象的属性来被查询。在浏览器中，window就是全局对象。</p><h5 id="确定this的值" tabindex="-1"><a class="header-anchor" href="#确定this的值" aria-hidden="true">#</a> 确定this的值</h5><p><strong>全局执行上下文</strong>中<code>this</code>指向全局对象</p><p><strong>函数执行上下文</strong>中，<code>this</code>的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显式绑定、<code>new</code>绑定、箭头函数。</p><h5 id="词法环境" tabindex="-1"><a class="header-anchor" href="#词法环境" aria-hidden="true">#</a> 词法环境</h5><p>两个组成部分：</p><ul><li><strong>环境记录</strong>：存储变量和函数声明的实际位置；</li><li><strong>对外部环境的引用</strong>：可以访问其外部词法环境。</li></ul><p>两种类型：</p><ul><li><strong>全局环境</strong>：是一个没有外部环境的词法环境，其外部环境引用为 <strong>null</strong>。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，<code>this</code> 的值指向这个全局对象。</li><li><strong>函数环境</strong>：用户在函数中定义的变量被存储在<strong>环境记录</strong>中，包含了<code>arguments</code> 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</li></ul><h5 id="变量环境" tabindex="-1"><a class="header-anchor" href="#变量环境" aria-hidden="true">#</a> 变量环境</h5><p>也是一个词法环境，因此具有词法环境的所有属性</p><p>在ES6中，词法环境和变量环境的区别在于前者用于存储函数声明和变量绑定，而后者仅用于存储变量绑定。</p><p><strong>变量提升</strong>的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 <code>undefined</code>（在 <code>var</code> 的情况下）或保持未初始化（在 <code>let</code> 和 <code>const</code> 的情况下）。所以这就是为什么可以在声明之前访问 <code>var</code> 定义的变量（尽管是 <code>undefined</code> ），但如果在声明之前访问 <code>let</code> 和 <code>const</code> 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。</p><h4 id="执行阶段" tabindex="-1"><a class="header-anchor" href="#执行阶段" aria-hidden="true">#</a> 执行阶段</h4><p>变量赋值、函数的引用、执行其他代码</p><p>此阶段，完成对所有变量的分配，最后执行代码。</p><p>如果 Javascript 引擎在源代码中声明的实际位置找不到 <code>let</code> 变量的值，那么将为其分配 <code>undefined</code> 值。</p><h2 id="执行栈-调用栈" tabindex="-1"><a class="header-anchor" href="#执行栈-调用栈" aria-hidden="true">#</a> 执行栈（调用栈）</h2><p>存储代码运行期间的所有<strong>执行上下文</strong>。</p><ol><li>当JS引擎第一次遇到JS脚本时，会创建一个<strong>全局的执行上下文</strong>并且压入当前执行栈；</li><li>每当JS 引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部</li><li>当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文</li><li>一旦所有代码执行完毕，JS 引擎从当前栈中移除全局执行上下文</li></ol><h3 id="全局、函数、eval执行上下文" tabindex="-1"><a class="header-anchor" href="#全局、函数、eval执行上下文" aria-hidden="true">#</a> 全局、函数、Eval执行上下文</h3><p>执行上下文分为<code>全局、函数、Eval执行上下文</code>三种类型</p><p>1）<strong>全局执行上下文</strong>（浏览器环境下，为全局的 <code>window</code> 对象），this指向这个全局对象；</p><p>2）<strong>函数执行上下文</strong>，每当一个函数被调用时, 都会为该函数创建一个新的执行上下文；</p><p>3）<strong>Eval 函数执行上下文</strong>，如eval(&quot;1 + 2&quot;)</p><p>对于每个执行上下文，都有三个重要属性：<code>变量对象、作用域链(Scope chain)、this</code></p><h3 id="执行上下文的特点" tabindex="-1"><a class="header-anchor" href="#执行上下文的特点" aria-hidden="true">#</a> 执行上下文的特点：</h3><p>1）单线程，只在主线程上运行；</p><p>2）同步执行，从上向下按顺序执行；</p><p>3）全局上下文只有一个，也就是<code>window</code>对象；</p><p>4）函数每调用一次就会产生一个新的执行上下文环境。</p><p>参考文章：</p><p>https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0</p>',45),t=[i];function n(c,h){return a(),d("div",null,t)}const p=e(r,[["render",n],["__file","执行上下文和执行栈.html.vue"]]);export{p as default};
