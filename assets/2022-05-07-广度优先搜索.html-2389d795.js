import{_ as a,W as e,X as r,a2 as h}from"./framework-609d4fec.js";const d={},t=h('<p>参考：https://github.com/diandianyezi/javascript-algorithms/blob/master/src/data-structures/graph/README.zh-CN.md</p><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><h3 id="图" tabindex="-1"><a class="header-anchor" href="#图" aria-hidden="true">#</a> 图</h3><p>图结构是描述和解决实际应用问题的一种基本而有力的公爵。图可定义为： $$ G= (V, E) $$ 集合V中的元素称作顶点，集合E中的元素分别对应V中的某一对顶点(u,v)，表示它们之间存在某种关系，故称作边。</p><h3 id="无向图、有向图及混合图" tabindex="-1"><a class="header-anchor" href="#无向图、有向图及混合图" aria-hidden="true">#</a> 无向图、有向图及混合图</h3><p>有向边</p><p>无向边</p><p>有向图的通用性更强，因为无向图和混合图都可以转化为有向图。</p><h3 id="度" tabindex="-1"><a class="header-anchor" href="#度" aria-hidden="true">#</a> 度</h3><p>在无向图中，与顶点v关联的边数，称作v的度数，记作deg(v)；</p><p>对于有向边e=(u,v),e称作v的出边，称作v的入边。v的出边综述称作其出度，入边总数称作入度。</p><h3 id="简单图" tabindex="-1"><a class="header-anchor" href="#简单图" aria-hidden="true">#</a> 简单图</h3><p>自环：联结于同一顶点之间的边</p><p>不含任何自换的路称为简单图</p><h3 id="通路与环路" tabindex="-1"><a class="header-anchor" href="#通路与环路" aria-hidden="true">#</a> 通路与环路</h3><p>简单通路</p><p>环路 简单环路 欧拉环路 哈尔密顿环路</p><p>有向无环图</p><h3 id="带权网络" tabindex="-1"><a class="header-anchor" href="#带权网络" aria-hidden="true">#</a> 带权网络</h3><p>带权图</p><h3 id="复杂度" tabindex="-1"><a class="header-anchor" href="#复杂度" aria-hidden="true">#</a> 复杂度</h3><p>无线图的边不会超过n * (n - 1)/ 2，有向图至多可能有n * (n - 1)</p><h3 id="图遍历算法概述" tabindex="-1"><a class="header-anchor" href="#图遍历算法概述" aria-hidden="true">#</a> 图遍历算法概述</h3><p>图遍历需要访问所有的边一次且仅一次，访问所有的点一次且仅一次。</p><h4 id="广度优先搜索" tabindex="-1"><a class="header-anchor" href="#广度优先搜索" aria-hidden="true">#</a> 广度优先搜索</h4><p>Breadth-first search 采用的策略是 <strong>越早访问的顶点，它的邻居越优先被选用</strong></p><blockquote><p>反复从波峰集中找到最早被访问的顶点v，若其邻居均已访问到，则将其逐出波峰集；否则，随意选出一个尚未访问到的邻居，并将其加入到波峰集中</p></blockquote><p>等同于树的层次遍历</p><p>练习：https://leetcode-cn.com/problems/same-tree/</p><h3 id="深度优先遍历" tabindex="-1"><a class="header-anchor" href="#深度优先遍历" aria-hidden="true">#</a> 深度优先遍历</h3><p>Depth-first search 选取下一顶点的策略，可概括为：</p><blockquote><p>优先选取最后一个被访问到的顶点的邻居</p></blockquote><p>首先访问顶点s，再从s所有尚未访问到的邻居中任取其一，并以之为基点，递归地执行DFS搜索。故各顶点被访问到的次序，类似于树的先序遍历；而各定点被访问完毕的次序，则类似于树的后序遍历。</p>',33),i=[t];function n(p,s){return e(),r("div",null,i)}const o=a(d,[["render",n],["__file","2022-05-07-广度优先搜索.html.vue"]]);export{o as default};
