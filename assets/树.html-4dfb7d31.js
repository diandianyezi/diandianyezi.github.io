import{_ as a,W as e,X as i,a2 as r}from"./framework-609d4fec.js";const h={},n=r('<h1 id="树" tabindex="-1"><a class="header-anchor" href="#树" aria-hidden="true">#</a> 树</h1><h2 id="树的定义" tabindex="-1"><a class="header-anchor" href="#树的定义" aria-hidden="true">#</a> 树的定义</h2><p>树是n(n &gt;= 0)个结点的有限集。</p><p>空树：结点数为0的树。</p><p>在任意一棵非空树中：有且仅有一个特定的成为根（Root）的结点；当n &gt; 1时，其余节点可分为m(m &gt; 0)个互不相交的有限集T~1~、T~2~、T~3~....T~m~，其中每一个集合本身又是一棵树，并且成为根的子树。</p><h3 id="结点分类" tabindex="-1"><a class="header-anchor" href="#结点分类" aria-hidden="true">#</a> 结点分类</h3><p>树的结点包含一个数据元素及若干指向子树的分支。</p><p>结点拥有的子树数成为结点的度。</p><p>度为0的树成为叶子结点或终端节点。</p><p>度不为0的结点成为非终端结点或分支结点。</p><p>除根节点之外，分支节点也称为内部结点。</p><p>树的度是树内各个结点的度的最大值。</p><h3 id="结点间关系" tabindex="-1"><a class="header-anchor" href="#结点间关系" aria-hidden="true">#</a> 结点间关系</h3><p>结点的子树的根节点称为<strong>该结点的孩子</strong>。该结点称为孩子的<strong>双亲</strong>。</p><p>同一个双亲的孩子之间互称<strong>兄弟</strong>。</p><p><strong>结点的祖先</strong>是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为<strong>该结点的子孙</strong>。</p><p>结点的层次level 是从根开始定义起，根作为第一层，</p><p>树中结点的最大层次称为树的<strong>深度Depth或高度</strong>。</p><p>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称为<strong>有序树</strong>，否则为<strong>无序树</strong>。</p><p>**森林：**是m(m&gt;=0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。</p><h2 id="树抽象数据类型" tabindex="-1"><a class="header-anchor" href="#树抽象数据类型" aria-hidden="true">#</a> 树抽象数据类型</h2><p>![image-20230117172544358](../../../../Library/Application Support/typora-user-images/image-20230117172544358.png)</p><h3 id="树的存储结构" tabindex="-1"><a class="header-anchor" href="#树的存储结构" aria-hidden="true">#</a> 树的存储结构</h3><p>双亲表示法</p><p>孩子表示法</p><p>孩子兄弟表示法</p><h2 id="二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树" aria-hidden="true">#</a> 二叉树</h2><p>二叉树特点：</p><ul><li>每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。</li><li>左子树和右子树是有次序的，次序不能任意颠倒。</li></ul><p>二叉树具有五种形态：</p><ol><li>空二叉树</li><li>只有一个根节点</li><li>根节点只有左子树</li><li>根节点只有右子树</li><li>根节点既有左子树又有右子树</li></ol><h3 id="特殊二叉树" tabindex="-1"><a class="header-anchor" href="#特殊二叉树" aria-hidden="true">#</a> 特殊二叉树</h3><h4 id="斜树" tabindex="-1"><a class="header-anchor" href="#斜树" aria-hidden="true">#</a> 斜树</h4><p>左斜树</p><p>右斜树</p><h4 id="满二叉树" tabindex="-1"><a class="header-anchor" href="#满二叉树" aria-hidden="true">#</a> 满二叉树</h4><p>二叉树中，所有分支节点都存在左子树和右子树，并且所有叶子都在同一层上。</p><p>特点：</p><ol><li>叶子只能出现在最下一层。</li><li>非叶子节点的度一定是2</li><li>在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</li></ol><h4 id="完全二叉树" tabindex="-1"><a class="header-anchor" href="#完全二叉树" aria-hidden="true">#</a> 完全二叉树</h4><p>对一棵具有n个结点的二叉树按层序编号，如果编号为i(i&gt;=1 &amp;&amp; i &lt;= n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树成为完全二叉树。</p><p>特点：</p><ol><li>叶子节点只能出现在最下两层</li><li>最下层的叶子一定几种在左部连续位置</li><li>倒数二层，若有叶子结点，一定都在右部连续位置</li><li>如果结点度为1，则该结点只有左孩子：即不存在只有右子树的情况</li><li>同样结点数的二叉树，完全二叉树的深度最小。</li></ol><h3 id="二叉树的性质" tabindex="-1"><a class="header-anchor" href="#二叉树的性质" aria-hidden="true">#</a> 二叉树的性质</h3><p>性质1：在二叉树的第i层上至多有2^i-1^（i&gt;= 1）个结点。</p><p>性质2：深度为k的二叉树至多有2^k^-1个结点(k &gt;= 1)。</p><p>性质3：对任何一棵二叉树T，如果其终端结点数为n0，度为2的节点数为n2，则n0 = n2 + 1。</p><p>性质4：具有n个结点的完全二叉树的深度为|log~2~n+1|（|x|表示不大于x的最大整数）。</p><p>性质5：如果对一棵具有n个结点的完全二叉树（其深度为）的结点按层序编号。对任一结点i有：</p><ol><li>如果i =1，则结点i是二叉树的根，无双亲；如果i &gt; 1,则其双亲是结点。</li><li>如果2*i&gt;n,则结点i无做孩子（结点i为叶子结点）；否则其左孩子是结点2*i。</li><li>如果2*i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2*i+1。</li></ol><h3 id="二叉树存储结构" tabindex="-1"><a class="header-anchor" href="#二叉树存储结构" aria-hidden="true">#</a> 二叉树存储结构</h3><h4 id="顺序存储结构" tabindex="-1"><a class="header-anchor" href="#顺序存储结构" aria-hidden="true">#</a> 顺序存储结构</h4><p>用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标能体现结点之间的逻辑关系。</p><p>极端情况下，如果只有k个结点，却要配置2^k^-1个存储单元，很浪费。所以顺序存储结构一般只用于完全二叉树。</p><h4 id="链式存储结构" tabindex="-1"><a class="header-anchor" href="#链式存储结构" aria-hidden="true">#</a> 链式存储结构</h4><p>二叉链表</p><p>![image-20230119111133793](../../../../Library/Application Support/typora-user-images/image-20230119111133793.png)</p><h3 id="二叉树遍历" tabindex="-1"><a class="header-anchor" href="#二叉树遍历" aria-hidden="true">#</a> 二叉树遍历</h3><p><strong>Travering Binary Tree:</strong> <strong>从根节点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。</strong></p><h4 id="前序遍历" tabindex="-1"><a class="header-anchor" href="#前序遍历" aria-hidden="true">#</a> 前序遍历</h4><p>如果二叉树为空则返回空，否则先访问根节点，然后前序遍历左子树，再前序遍历右子树。</p><h4 id="中序遍历" tabindex="-1"><a class="header-anchor" href="#中序遍历" aria-hidden="true">#</a> 中序遍历</h4><p>如果二叉树为空则返回空，否则先中序遍历左子树，然后访问根节点，最后中序遍历右子树。</p><h4 id="后序遍历" tabindex="-1"><a class="header-anchor" href="#后序遍历" aria-hidden="true">#</a> 后序遍历</h4><p>如果二叉树为空则返回空，否则先后序遍历左子树，然后再后序遍历右子树，最后访问根节点。</p><h4 id="层序遍历" tabindex="-1"><a class="header-anchor" href="#层序遍历" aria-hidden="true">#</a> 层序遍历</h4><p>如果二叉树为空则返回空，否则从树的第一层开始访问，从上到下逐层遍历，同一层中，按从左到右的顺序对结点逐个访问。</p><h3 id="二叉树的建立" tabindex="-1"><a class="header-anchor" href="#二叉树的建立" aria-hidden="true">#</a> 二叉树的建立</h3>',68),d=[n];function p(t,l){return e(),i("div",null,d)}const o=a(h,[["render",p],["__file","树.html.vue"]]);export{o as default};
