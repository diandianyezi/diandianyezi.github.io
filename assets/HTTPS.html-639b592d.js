import{_ as e,W as a,X as d,a2 as o}from"./framework-609d4fec.js";const c={},r=o('<h1 id="https" tabindex="-1"><a class="header-anchor" href="#https" aria-hidden="true">#</a> HTTPS</h1><h2 id="https是什么" tabindex="-1"><a class="header-anchor" href="#https是什么" aria-hidden="true">#</a> HTTPS是什么</h2><p>HTTP + SSL/TLS</p><p>HTTP是明文传输，不安全。</p><h3 id="对称加密" tabindex="-1"><a class="header-anchor" href="#对称加密" aria-hidden="true">#</a> 对称加密</h3><p>公钥和私钥相同</p><h3 id="非对称加密" tabindex="-1"><a class="header-anchor" href="#非对称加密" aria-hidden="true">#</a> 非对称加密</h3><p><code>非对称加密</code>就是基于<code>公钥、私钥</code>的一种加密方式，<code>非对称加密</code>相比于<code>对称加密</code>安全性较强，因为黑客只可能知道<code>公钥</code>，而不可能知道<code>私钥</code>，而<code>公钥</code>加密的数据只能使用<code>私钥</code>解密，所以黑客盗取<code>公钥</code>后也解密不了客户端发给服务端的信息</p><p>缺点：</p><p><img src="https://raw.githubusercontent.com/diandianyezi/typora-images/master/img/image-20220901101233355.png" alt="image-20220901101233355"></p><h3 id="https加密方式" tabindex="-1"><a class="header-anchor" href="#https加密方式" aria-hidden="true">#</a> HTTPS加密方式</h3><p>对称加密 + 非对称加密</p><h3 id="证书" tabindex="-1"><a class="header-anchor" href="#证书" aria-hidden="true">#</a> 证书</h3><p>因为非对称加密 需要保证公钥不被窃取，就需要向<strong>证书颁发机构</strong> CA 申请<strong>证书</strong>了。</p><h4 id="证书组成" tabindex="-1"><a class="header-anchor" href="#证书组成" aria-hidden="true">#</a> 证书组成</h4><p>![image-20220825152231004](../../../../Library/Application Support/typora-user-images/image-20220825152231004.png)</p><h4 id="步骤" tabindex="-1"><a class="header-anchor" href="#步骤" aria-hidden="true">#</a> 步骤：</h4><ol><li><p><code>服务端</code>将 <code>公钥</code> 发给 <code>证书颁发机构</code>，向<code>证书颁发机构</code> 申请证书；</p></li><li><p><code>证书颁发机构</code> 自己也拥有一对<code>公钥、秘钥</code>，使用<code>秘钥</code>加密了服务端的<code>公钥</code>，同时根据服务端网址生成一个 <code>证书签名</code>，且也使用 <code>秘钥</code>加密这个证书签名，并制作成证书，将此证书发给服务端；</p></li><li><p>当客户端与 服务端通信时，服务端不再是直接把服务端公钥传给客户端，而是将刚刚的<code>证书</code>发给客户端。</p></li><li><p>当客户端收到<code>证书</code>后，会对此证书进行辨别真伪。**提前说明：当今各浏览器对各大证书颁发机构的名称和对应的机构公钥都进行了存储。**所以客户端收到证书后，只需要从浏览器本地找到对应的<code>机构公钥</code>，对证书签名进行解密，<strong>然后客户端会根据解密后的签名规则</strong>，自己也生成一个证书签名，如果两个签名一致，则通过。通过之后，客户端再次使用 机构公钥，解密出服务端公钥。</p></li><li><p>客户端自己生成一个对称秘钥key2，然后使用服务端公钥将 key2 进行加密，发送给服务端，服务端收到之后，使用服务端秘钥进行解密。</p></li><li><p>这之后，服务端和客户端通过对称秘钥key2进行对称加密的通信。</p></li></ol><h3 id="ssl-tls" tabindex="-1"><a class="header-anchor" href="#ssl-tls" aria-hidden="true">#</a> SSL/TLS</h3><p>上述操作都发生在SSL层。</p><blockquote><p>最新的TLS协议，是SSL协议的升级版，和SSL协议的大体原理是相同的</p></blockquote>',21),i=[r];function t(h,s){return a(),d("div",null,i)}const p=e(c,[["render",t],["__file","HTTPS.html.vue"]]);export{p as default};
