import{_ as s,W as o,X as c,Z as a,a1 as n,$ as t,a2 as d,C as i}from"./framework-609d4fec.js";const l={},p=d(`<h1 id="navigator-sendbeacon" tabindex="-1"><a class="header-anchor" href="#navigator-sendbeacon" aria-hidden="true">#</a> Navigator.sendBeacon</h1><p>可用于通过<code>HTTP POST</code>将少量数据 异步传输到Web服务器；主要用于将统计数据发送到Web服务器，同时避免了用传统技术（如：<code>XMLHTTPRequest</code>）发送分析数据的一些问题。</p><h2 id="语法" tabindex="-1"><a class="header-anchor" href="#语法" aria-hidden="true">#</a> 语法</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>navigator<span class="token punctuation">.</span><span class="token function">sendBeacon</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
navigator<span class="token punctuation">.</span><span class="token function">sendBeacon</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="参数" tabindex="-1"><a class="header-anchor" href="#参数" aria-hidden="true">#</a> 参数</h3><ol><li>url 表示data将要被发送到的网络地址。</li><li>data表示将要发送的 <code>ArrayBuffer</code>、<code>ArrayBufferView</code>、<code>Blob</code> 、 <code>DOMString</code>、<code>FormData</code>或 <code>URLSearchParams</code>类型的数据。</li></ol><h3 id="返回值" tabindex="-1"><a class="header-anchor" href="#返回值" aria-hidden="true">#</a> 返回值</h3><p>当用户代理成功地将数据加入到传输队列中时，返回<code>true</code>，否则返回 <code>false</code>。</p><h2 id="描述" tabindex="-1"><a class="header-anchor" href="#描述" aria-hidden="true">#</a> 描述</h2><p>该方法通过将数据发送到服务器来分析和诊断代码。这些代码通常尝试在卸载<code>unload</code> document之前向web服务器发送数据。然而，对于开发者来说保证在文档卸载期间发送数据一直是一个困难。因为用户代理通常会忽略在 <code>unload</code>事件处理器中产生的异步 <code>XMLHTTPRequest</code>。</p><p>为了解决这个问题，统计和诊断代码通常要在</p><ul><li>发起一个同步<code>XMLHTTPRequest</code>来发送数据</li><li>创建一个 <code>img</code> 元素并设置<code>src</code>，大部分用户代理会延迟卸载 <code>unload</code>文档以加载图像。</li><li>创建一个几秒的 no-op循环。</li></ul><p>上述的所有方法都会迫使用户代理延迟卸载文档，并使得下一个导航出现的更晚。</p><p>这就是 <strong><code>sendBeacon()</code></strong> 方法存在的意义。使用 <strong><code>sendBeacon()</code></strong> 方法会使用户代理在有机会时异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能，这意味着：</p><ul><li>数据发送是可靠的。</li><li>数据异步传输。</li><li>不影响下一导航的载入。</li></ul><h3 id="在会话结束时发送统计数据" tabindex="-1"><a class="header-anchor" href="#在会话结束时发送统计数据" aria-hidden="true">#</a> 在会话结束时发送统计数据</h3><p>网站通常希望在用户完成页面浏览后向服务器发送分析或诊断数据，最可靠的方法是 <code>visibilitychange</code>事件发生时发送数据：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;visibilitychange&#39;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">logData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>visibilityState <span class="token operator">===</span> <span class="token string">&#39;hidden&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    navigator<span class="token punctuation">.</span><span class="token function">sendBeacon</span><span class="token punctuation">(</span><span class="token string">&#39;/log&#39;</span><span class="token punctuation">,</span> analyticsData<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="避免使用unload和beforeunload" tabindex="-1"><a class="header-anchor" href="#避免使用unload和beforeunload" aria-hidden="true">#</a> 避免使用<code>unload</code>和<code>beforeunload</code></h3><p>在需要情况下（尤其是移动设备）浏览器不会产生 <code>unload</code> 和 <code>beforeunload</code> 和 <code>pagehide</code>事件。比如：</p><ol><li>用户加载了网页并与其交互；</li><li>完成浏览后，用户切换到其他应用程序，而不是关闭选项卡；</li><li>随后，用户通过手机的应用管理器关闭了浏览器应用。</li></ol><p>此外，unload事件与 back/forward cache(bfcache)在现代浏览器的实现是不兼容的。</p><ul><li>Firefox浏览器，通过排除包含unload和beforeunload事件的页面，来处理这种不兼容，因此损失了一些性能。</li><li>Safari和Chrome，在用户在同一个tab页导航到另一个页面时，不执行 unload，来处理这种不兼容。</li></ul><h3 id="使用-pagehide-作为回退" tabindex="-1"><a class="header-anchor" href="#使用-pagehide-作为回退" aria-hidden="true">#</a> 使用 pagehide 作为回退</h3>`,24),r={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/pagehide_event",target:"_blank",rel:"noopener noreferrer"},u=a("code",null,"pagehide",-1),h=a("code",null,"visibilitychange",-1),k=a("code",null,"beforeunload",-1),v=a("code",null,"unload",-1);function b(f,g){const e=i("ExternalLinkIcon");return o(),c("div",null,[p,a("p",null,[n("可使用 "),a("a",r,[u,t(e)]),n(" 事件来代替部分浏览器未实现的 "),h,n(" 事件。和 "),k,n(" 与 "),v,n(" 事件类似，这一事件不会被可靠地触发（特别是在移动设备上），但它与 bfcache 兼容。")])])}const m=s(l,[["render",b],["__file","20230403-Navigator.sendBeacon (copy).html.vue"]]);export{m as default};
