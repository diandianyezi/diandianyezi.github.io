import{_ as n,W as a,X as s,a2 as e}from"./framework-609d4fec.js";const p={},t=e(`<h1 id="线性表" tabindex="-1"><a class="header-anchor" href="#线性表" aria-hidden="true">#</a> 线性表</h1><p>线性表（List）：0个或多个数据元素的有限序列</p><p>若将线性表记为(a1，...，ai-1，ai，ai+1，...，an)，则表中ai-1领先于ai，ai+1领先 于ai，称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。当i=1，2，...，n-1时， ai有且仅有一个直接后继，当i=2，3，...，n时，ai有且仅有一个直接前驱。</p><p>线性表元素的个数n(n≥0)定义为线性表的长度，当n=0时，称为空表。</p><h3 id="线性表的抽象数据类型" tabindex="-1"><a class="header-anchor" href="#线性表的抽象数据类型" aria-hidden="true">#</a> 线性表的抽象数据类型</h3><p>线性表的抽象数据类型定义：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ADT 线性表<span class="token punctuation">(</span>List<span class="token punctuation">)</span>
Data
    线性表的数据对象集合为<span class="token punctuation">{</span>a1,a2<span class="token punctuation">..</span>.an<span class="token punctuation">}</span>,每个元素的类型均为		DataType。
    除第一个元素外，每个元素有且仅有一个直接前驱元素。
    除最后一个元素外，每个元素有且仅有一个直接后继元素。
    数据元素之间的关系是一对一的关系。
Operation
    InitList<span class="token punctuation">(</span>*L<span class="token punctuation">)</span>：初始化操作，建立一个空的线性表
    ListEmpty<span class="token punctuation">(</span>L<span class="token punctuation">)</span>: 判断线性表是否为空
    ClearList<span class="token punctuation">(</span>*L<span class="token punctuation">)</span>: 将线性表清空
    GetElem<span class="token punctuation">(</span>L, i, *e<span class="token punctuation">)</span>: 将馅饼表L中的第i个位置元素值返回给e
    Location<span class="token punctuation">(</span>L, e<span class="token punctuation">)</span>: 在线性表中查找与给定值e相等的元素，如果查找成功就返回序号。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="线性表的顺序存储结构" tabindex="-1"><a class="header-anchor" href="#线性表的顺序存储结构" aria-hidden="true">#</a> 线性表的顺序存储结构</h3><h4 id="顺序存储结构" tabindex="-1"><a class="header-anchor" href="#顺序存储结构" aria-hidden="true">#</a> 顺序存储结构：</h4><p>指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code> <span class="token comment">/* 存储空间初始分配量 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">20</span></span></span>
<span class="token comment">/* ElemType类型根据实际情况而定，这里假设为int */</span> 
<span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment">/* 数组存储数据元素，最大值为MAXSIZE */</span> 
  ElemType data<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token comment">/* 线性表当前长度 */</span>
	<span class="token keyword">int</span> length<span class="token punctuation">;</span>
<span class="token punctuation">}</span> SqList<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>描述顺序存储结构需要三个属性：</p><ul><li>存储空间的起始位置</li><li>线性表的最大存储容量</li><li>线性表的当前长度</li></ul><p>数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的。线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个 量是变化的。</p><p>在任意时刻，线性表的长度应该小于等于数组的长度。</p><h4 id="地址计算方法" tabindex="-1"><a class="header-anchor" href="#地址计算方法" aria-hidden="true">#</a> 地址计算方法</h4><p>由第一个元素的存储位置可以推算出任意第i个元素的存储位置：</p><p>LOC(a~i~) = LOC(a~1~)+(i-1)* c</p><p>所以，存取元素的时间复杂度为O(1)。这种存取结构成为随机存取结构。</p><h4 id="顺序存储结构的插入与删除" tabindex="-1"><a class="header-anchor" href="#顺序存储结构的插入与删除" aria-hidden="true">#</a> 顺序存储结构的插入与删除</h4><h5 id="获取元素操作" tabindex="-1"><a class="header-anchor" href="#获取元素操作" aria-hidden="true">#</a> 获取元素操作</h5><p>只要i在数组下边范围内，就可以返回，否则返回-1</p><p>时间复杂度O(1)</p><h5 id="插入操作" tabindex="-1"><a class="header-anchor" href="#插入操作" aria-hidden="true">#</a> 插入操作</h5><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 在arr数组的第i个位置中插入ele</span>
<span class="token keyword">function</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ele</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&gt;</span> len <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token operator">=</span> len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&gt;=</span> i <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      arr<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  arr<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> ele<span class="token punctuation">;</span>
  <span class="token keyword">return</span> arr
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="删除操作" tabindex="-1"><a class="header-anchor" href="#删除操作" aria-hidden="true">#</a> 删除操作</h5><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">deleteEle</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 第i个元素</span>
  <span class="token keyword">let</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length

  <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> len <span class="token operator">||</span> i <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token operator">=</span> i<span class="token punctuation">;</span> k <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      arr<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  arr<span class="token punctuation">.</span>length <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span>
  <span class="token keyword">return</span> arr
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度O(n)</p><h4 id="线性表顺序存储结构的优缺点" tabindex="-1"><a class="header-anchor" href="#线性表顺序存储结构的优缺点" aria-hidden="true">#</a> 线性表顺序存储结构的优缺点</h4><p>优点：</p><ul><li>无需为表示表中元素之间的逻辑关系而增加额外的存储空间</li><li>可以快速地存取表中任一位置的元素</li></ul><p>缺点：</p><ul><li>插入和删除操作需要移动大量元素</li><li>当线性表长度变化较大时，难以确定存储空间的容量</li><li>造成存储空间的“碎片”</li></ul><h3 id="线性表的链式存储结构" tabindex="-1"><a class="header-anchor" href="#线性表的链式存储结构" aria-hidden="true">#</a> 线性表的链式存储结构</h3><p>为了解决顺序存储结构的缺点（由于相邻元素的存储位置也代表着邻居关系，插入和删除时需要移动大量元素），用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。</p><p>链式结构中，除了要存数据元素信息外，还需要存储它后继元素的存储地址。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
  ElemType data<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> Node<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span>LinkList<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="单链表的读取和删除" tabindex="-1"><a class="header-anchor" href="#单链表的读取和删除" aria-hidden="true">#</a> 单链表的读取和删除</h4><p>读取的时间复杂度O(n) 和删除的时间复杂都是O(n)</p><p>首先需要找到目标节点，花费O(n)，真正的读取和删除只花费O(1)。</p><p>对于插入和删除数据比较频繁的操作，单链表的效率优势就越是明显。</p><h4 id="单链表的整表创建" tabindex="-1"><a class="header-anchor" href="#单链表的整表创建" aria-hidden="true">#</a> 单链表的整表创建</h4><p>动态结构。所占用的空间大小和位置是不需要预先分配划定的。</p><h5 id="头插法" tabindex="-1"><a class="header-anchor" href="#头插法" aria-hidden="true">#</a> 头插法</h5><h5 id="尾插法" tabindex="-1"><a class="header-anchor" href="#尾插法" aria-hidden="true">#</a> 尾插法</h5><h4 id="单链表的整表删除" tabindex="-1"><a class="header-anchor" href="#单链表的整表删除" aria-hidden="true">#</a> 单链表的整表删除</h4><p>算法思路：</p><ol><li>声明一个指针p和q；</li><li>将第一个结点赋值给p；</li><li>循环： <ul><li>将下一结点复制给q；</li><li>释放p；</li><li>将q赋值给p。</li></ul></li></ol><h4 id="单链表结构与顺序存储结构优缺点" tabindex="-1"><a class="header-anchor" href="#单链表结构与顺序存储结构优缺点" aria-hidden="true">#</a> 单链表结构与顺序存储结构优缺点</h4><p><strong>存储分配方式</strong>：顺序存储结构用一段连续的存储单元依次存储线性表的数据元素；单链表采用链式存储结构，用一组任意的存储单元存当线性表的元素。</p><p><strong>时间性能</strong>：查找：O(1) O(n);插入和删除：O(n)、单链表在找出某位置的指针后，插入和删除时间为O(1)。</p><p><strong>空间性能</strong>：顺序存储结构需要预分配存储空间，分大了，浪费；链表不需要分配存储空间。</p><h4 id="静态链表" tabindex="-1"><a class="header-anchor" href="#静态链表" aria-hidden="true">#</a> 静态链表</h4><h4 id="循环链表-circle-linked-list" tabindex="-1"><a class="header-anchor" href="#循环链表-circle-linked-list" aria-hidden="true">#</a> 循环链表 circle linked list</h4><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表成为单循环链表。</p><p>循环链表和单链表的主要差异就在于循环的判断条件上，原来为 p -&gt;next === null,现在则是p-&gt;next ===头结点。</p><p>为了查找头结点和尾节点更快，可以用尾指针来表示循环链表。</p><p><img src="https://raw.githubusercontent.com/diandianyezi/typora-images/master/img/202301112222018.png" alt="image-20230111222159935"></p><p>要将两个循环链表合并成一个表时，有了尾指针就非常简单了。</p><p><img src="https://raw.githubusercontent.com/diandianyezi/typora-images/master/img/202301112224787.png" alt="image-20230111222406685"></p><h4 id="双向链表" tabindex="-1"><a class="header-anchor" href="#双向链表" aria-hidden="true">#</a> 双向链表</h4><h4 id="双向循环链表" tabindex="-1"><a class="header-anchor" href="#双向循环链表" aria-hidden="true">#</a> 双向循环链表</h4><h5 id="插入" tabindex="-1"><a class="header-anchor" href="#插入" aria-hidden="true">#</a> 插入</h5><p>将节点s插入到双向循环链表的p和q之间：</p><blockquote><p>s -&gt; prior = p;</p><p>s-&gt; next = p-&gt;next</p><p>p-&gt;next-&gt;prior = s</p><p>p-&gt;next = s</p></blockquote><p>先搞定s的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继。</p><h5 id="删除" tabindex="-1"><a class="header-anchor" href="#删除" aria-hidden="true">#</a> 删除</h5><p>删除节点p</p><blockquote><p>p-&gt;prior-&gt;next = p.next;</p><p>p-&gt;next-&gt;prior = p-&gt;prior;</p><p>free(p);</p></blockquote><p>用空间来换时间</p><h3 id="总结回顾" tabindex="-1"><a class="header-anchor" href="#总结回顾" aria-hidden="true">#</a> 总结回顾</h3><p><strong>线性表</strong>：0个或多个具有相同类型的数据元素的有限序列。</p><p><strong>顺序存储结构</strong>：用一段地址连续的存储单元依次存储线性表的数据元素。用数组实现。</p><p><strong>链式存储结构</strong>：不受固定的存储空间限制</p>`,74),i=[t];function o(l,c){return a(),s("div",null,i)}const d=n(p,[["render",o],["__file","线性表.html.vue"]]);export{d as default};
