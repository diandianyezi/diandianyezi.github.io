import{_ as e,W as n,X as s,a2 as o}from"./framework-609d4fec.js";const c={},a=o(`<h6 id="npm-run-xxx到底执行了什么" tabindex="-1"><a class="header-anchor" href="#npm-run-xxx到底执行了什么" aria-hidden="true">#</a> npm run xxx到底执行了什么？</h6><p>今日看到的一个有趣帖子</p><p>https://juejin.cn/post/7078924628525056007</p><p>package.json文件</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;h5&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;version&quot;</span><span class="token operator">:</span> <span class="token string">&quot;1.0.7&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;private&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token property">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;serve&quot;</span><span class="token operator">:</span> <span class="token string">&quot;vue-cli-service serve&quot;</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接执行<code>vue-cli-service serve</code>，会报错，因为操作系统中没有存在<code>vue-cli-service</code>这一条指令，那为啥<code>npm run</code> 的时候就可以执行呢？</p><h6 id="原因如下" tabindex="-1"><a class="header-anchor" href="#原因如下" aria-hidden="true">#</a> 原因如下：</h6><p>在安装依赖的时候，通过<code>npm i xxx </code>执行，例如 <code>npm i @vue/cli-service</code>，npm 在 安装这个依赖的时候，就会根据 <code>@vue/cli-service</code> 的<code>package.json</code> 文件中的 <code>bin</code>配置，在 <code>node_modules/.bin/</code> 目录下创建 <code>vue-cli-service</code> 为名的几个可执行文件了。这些可执行文件其实是一个替身文件（软连接文件）指向 <code>vue-cli-service</code> 的 <code>package.json</code>文件里 <code>bin</code>配置指向的那个文件。</p><p><code>.bin</code>目录这个目录不是一个npm包。该目录下的文件，表示这是一个个软连接，打开文件可以看到文件顶部写着<code>#!/bin/sh</code>，表示这是一个脚本。</p><p>由此我们可以知道，当使用 <code>npm run serve</code> 执行 <code>vue-cli-service serve</code> 时，虽然没有安装 <code>vue-cli-service</code>的全局命令，但是 npm 会到 <code>./node_modules/.bin</code> 中找到 <code>vue-cli-service</code> 文件作为 脚本来执行，则相当于执行了 <code>./node_modules/.bin/vue-cli-service serve</code>（最后的 serve 作为参数传入）。</p><p>那么<code>.bin</code>目录下的文件表示软连接，那这个<code>bin</code>目录下的那些软连接文件是哪里来的呢？它又是怎么知道这条软连接是哪里执行的呢？从 <code>package-lock.json</code> 中可知，当我们<code>npm i</code> 整个新建的vue项目的时候，<code>npm</code> 将 <code>bin/vue-cli-service.js</code> 作为 <code>bin</code> 声明了。</p><p>每当执行 <code>npm run</code>，会自动新建一个 Shell，npm run 新建的这个Shell，会将当前目录的 <code>node/modules/.bin</code>子目录加入 PATH变量，执行结束后，再将 PATH变量恢复原样。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ol><li>运行 npm run xxx的时候，npm 会先在当前目录的 node_modules/.bin 查找要执行的程序，如果找到则运行；</li><li>没有找到则从全局的 node_modules/.bin 中查找，npm i -g xxx就是安装到到全局目录；</li><li>如果全局目录还是没找到，那么就从 path 环境变量中查找有没有其他同名的可执行程序。</li></ol><p>作者：阳光是sunny 链接：https://juejin.cn/post/7078924628525056007 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>`,15),p=[a];function d(i,t){return n(),s("div",null,p)}const l=e(c,[["render",d],["__file","2022-04-06-npm run 到底执行了什么.html.vue"]]);export{l as default};
