import{_ as t,W as o,X as a,Z as e,$ as r,a1 as n,a2 as l,C as i}from"./framework-609d4fec.js";const c={},d=l(`<h1 id="resize-observer-api" tabindex="-1"><a class="header-anchor" href="#resize-observer-api" aria-hidden="true">#</a> Resize Observer API</h1><p>在最近的需求开发中，新接触了这个API，日常记录一下。</p><p>这是一种无侵入的观察方式，可以在完全不影响目标元素业务逻辑的同时，嵌入需要响应变化的功能逻辑，例如发送埋点数据。减轻了开发者的心智负担和维护成本。</p><h2 id="resizeobserver" tabindex="-1"><a class="header-anchor" href="#resizeobserver" aria-hidden="true">#</a> ResizeObserver</h2><p><code>ResizeObserver</code>接口监视<code>Element</code>内容盒或边框盒或者<code>SVGElement</code>边界尺寸的变化。</p><p><code>ResizeObserver</code>避免了通过回调函数调整大小时，通常创建的无限回调循环和循环依赖项。它只能通过在后续的帧中处理DOM中更深层次的元素来做到这一点。如果它的实现遵循规范，则应在绘制前和布局后调用 resize 事件。</p><h3 id="构造函数" tabindex="-1"><a class="header-anchor" href="#构造函数" aria-hidden="true">#</a> 构造函数</h3><p>ResizeObserver()：创建并返回一个新的ResizeObserver对象</p><h3 id="属性" tabindex="-1"><a class="header-anchor" href="#属性" aria-hidden="true">#</a> 属性</h3><p>无</p><h3 id="方法" tabindex="-1"><a class="header-anchor" href="#方法" aria-hidden="true">#</a> 方法</h3><ul><li><p>ResizeObserver.disconnect()</p><p>取消特定观察者目标上所有对Element的监听。</p></li><li><p>ResizeObserver.observe()</p><p>开始对指定Element的监听</p></li><li><p>ResizeObserver.unobserve()</p><p>结束对指定Element的监听</p></li></ul><h3 id="代码示例" tabindex="-1"><a class="header-anchor" href="#代码示例" aria-hidden="true">#</a> 代码示例</h3><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ResizeObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token parameter">entries</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> entry <span class="token keyword">of</span> entries<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> rect <span class="token operator">=</span> entry<span class="token punctuation">.</span>contentRect<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>entry.contentRect</code>返回的是一个DOMRect对象，其中包含了目标元素的x, y, width, height, top, bottom, left, right等属性。</li></ul><h3 id="兼容性" tabindex="-1"><a class="header-anchor" href="#兼容性" aria-hidden="true">#</a> 兼容性</h3><p><img src="https://raw.githubusercontent.com/diandianyezi/typora-images/master/img/202312231548922.png" alt="image-20231223154829492"></p><h2 id="resizeobserverentry" tabindex="-1"><a class="header-anchor" href="#resizeobserverentry" aria-hidden="true">#</a> ResizeObserverEntry</h2>`,18),p={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserverEntry",target:"_blank",rel:"noopener noreferrer"},h=e("code",null,"ResizeObserverEntry",-1),b=e("strong",null,[e("code",null,"ResizeObserverEntry")],-1),u={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver/ResizeObserver",target:"_blank",rel:"noopener noreferrer"},_=e("code",null,"ResizeObserver()",-1),v={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element",target:"_blank",rel:"noopener noreferrer"},z=e("code",null,"Element",-1),m={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/SVGElement",target:"_blank",rel:"noopener noreferrer"},k=e("code",null,"SVGElement",-1),f=e("h3",{id:"属性-1",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#属性-1","aria-hidden":"true"},"#"),n(" 属性")],-1),g={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserverEntry/borderBoxSize",target:"_blank",rel:"noopener noreferrer"},R=e("code",null,"ResizeObserverEntry.borderBoxSize",-1),O={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserverEntry/contentBoxSize",target:"_blank",rel:"noopener noreferrer"},y=e("code",null,"ResizeObserverEntry.contentBoxSize",-1),E={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserverEntry/devicePixelContentBoxSize",target:"_blank",rel:"noopener noreferrer"},x=e("code",null,"ResizeObserverEntry.devicePixelContentBoxSize",-1),I={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserverEntry/contentRect",target:"_blank",rel:"noopener noreferrer"},P=e("code",null,"ResizeObserverEntry.contentRect",-1),C={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/DOMRectReadOnly",target:"_blank",rel:"noopener noreferrer"},N=e("code",null,"DOMRectReadOnly",-1),A={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserverEntry/target",target:"_blank",rel:"noopener noreferrer"},W=e("code",null,"ResizeObserverEntry.target",-1),S={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element",target:"_blank",rel:"noopener noreferrer"},w=e("code",null,"Element",-1),B={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/SVGElement",target:"_blank",rel:"noopener noreferrer"},V=e("code",null,"SVGElement",-1),G=e("p",null,"需要实现一个功能：根据页面大小，设置底部协议展示是吸底展示还是在页面底部向下滚动后展示。最终想的方案根据监听页面两个dom元素的高度，如果这两个元素的高度之和大于页面高度，就将第二个元素的position设置为relative相对定位，小于页面高度，就将position设置为absolute绝对布局，吸底展示。",-1);function D(M,j){const s=i("ExternalLinkIcon");return o(),a("div",null,[d,e("p",null,[e("a",p,[h,r(s)]),n("描述已调整大小的单个元素，标识钙元素及其新大小。")]),e("p",null,[b,n(" 接口是传递给 "),e("a",u,[_,r(s)]),n(" 构造函数中的回调函数参数的对象，它允许你获取真正在观察的 "),e("a",v,[z,r(s)]),n(" 或 "),e("a",m,[k,r(s)]),n(" 最新的大小。")]),f,e("p",null,[e("a",g,[R,r(s)]),n("：只读，一个对象，当运行回调时，该对象包含着正在观察元素的新边框盒的大小。")]),e("p",null,[e("a",O,[y,r(s)]),n(" ：只读，一个对象，当运行回调时，该对象包含着正在观察元素的新内容盒的大小。")]),e("p",null,[e("a",E,[x,r(s)]),n(" ：只读，一个对象，当运行回调时，该对象包含着正在观察元素的新内容盒的大小（以设备像素为单位）。")]),e("p",null,[e("a",I,[P,r(s)]),n(" ：只读，一个对象，当运行回调时，该对象包含着正在观察元素新大小的 "),e("a",C,[N,r(s)]),n(" 对象。请注意，这比以上两个属性有着更好的支持，但是它是 Resize Observer API 早期实现遗留下来的，出于对浏览器的兼容性原因，仍然被保留在规范中，并且在未来的版本中可能被弃用。")]),e("p",null,[e("a",A,[W,r(s)]),n(" ：只读，对正在观察 "),e("a",S,[w,r(s)]),n(" 或 "),e("a",B,[V,r(s)]),n(" 的引用。")]),G])}const T=t(c,[["render",D],["__file","20231223-ResizeObserver.html.vue"]]);export{T as default};
