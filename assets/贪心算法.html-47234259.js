const e=JSON.parse('{"key":"v-f64f1d9e","path":"/article/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html","title":"贪心算法","lang":"zh-CN","frontmatter":{"description":"贪心算法 (greeedy algorithm) 在问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做的是在某种意义上的局部最优解。 贪心算法并不保证会得到最优解，但在某些问题上贪心算法的解就是最优解。 适用范围 在最优子结构问题中尤为有效。最优子结构的意思是问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。 证明 贪心有两种证明方法：反证法和归纳法； 如果交换方案中任意两个元素/相邻的两个元素后，答案不会变得更好，name可以推定目前的解已经是最优解了； 归纳法：先算得出边界情况的最优解F~1~，然后再证明每个n，F~n+1~都可以由F~n~推导得出结果。","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-v2-demo.netlify.app/article/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"Yezi’s Blog"}],["meta",{"property":"og:title","content":"贪心算法"}],["meta",{"property":"og:description","content":"贪心算法 (greeedy algorithm) 在问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做的是在某种意义上的局部最优解。 贪心算法并不保证会得到最优解，但在某些问题上贪心算法的解就是最优解。 适用范围 在最优子结构问题中尤为有效。最优子结构的意思是问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。 证明 贪心有两种证明方法：反证法和归纳法； 如果交换方案中任意两个元素/相邻的两个元素后，答案不会变得更好，name可以推定目前的解已经是最优解了； 归纳法：先算得出边界情况的最优解F~1~，然后再证明每个n，F~n+1~都可以由F~n~推导得出结果。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-15T13:30:52.000Z"}],["meta",{"property":"article:modified_time","content":"2023-03-15T13:30:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"贪心算法\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-03-15T13:30:52.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":3,"title":"适用范围","slug":"适用范围","link":"#适用范围","children":[]},{"level":3,"title":"证明","slug":"证明","link":"#证明","children":[]},{"level":2,"title":"经典示例","slug":"经典示例","link":"#经典示例","children":[{"level":3,"title":"找零问题","slug":"找零问题","link":"#找零问题","children":[]},{"level":3,"title":"背包问题","slug":"背包问题","link":"#背包问题","children":[]}]}],"git":{"createdTime":1678887052000,"updatedTime":1678887052000,"contributors":[{"name":"zhangting","email":"1092923594@qq.com","commits":1}]},"readingTime":{"minutes":0.98,"words":295},"filePathRelative":"article/贪心算法.md","localizedDate":"2023年3月15日","excerpt":"<h1> 贪心算法</h1>\\n<p>(greeedy algorithm)</p>\\n<p>在问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做的是在某种意义上的局部最优解。</p>\\n<p>贪心算法并不保证会得到最优解，但在某些问题上贪心算法的解就是最优解。</p>\\n<h3> 适用范围</h3>\\n<p>在最优子结构问题中尤为有效。最优子结构的意思是问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。</p>\\n<h3> 证明</h3>\\n<p>贪心有两种证明方法：反证法和归纳法；</p>\\n<ol>\\n<li>如果交换方案中任意两个元素/相邻的两个元素后，答案不会变得更好，name可以推定目前的解已经是最优解了；</li>\\n<li>归纳法：先算得出边界情况的最优解F~1~，然后再证明每个n，F~n+1~都可以由F~n~推导得出结果。</li>\\n<li></li>\\n</ol>","autoDesc":true}');export{e as data};
