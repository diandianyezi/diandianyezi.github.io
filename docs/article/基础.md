---
title: 数据结构
---



**数据结构：是互相存在一种或多种特定关系的数据元素的集合**。一门研究非值计算的程序设计问题中的操作对象，以及它们之前的关系和操作等相关问题的学科。

程序设计 = 数据结构 + 算法

## 基本概念和术语

### 数据

是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。

数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。

### 数据元素

是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。

### 数据项

一个数据元素可以由若干个数据项组成。是数据不可分割的最小单位。

### 数据对象

是性质相同的数据元素的集合，是数据的子集。

## 逻辑结构

逻辑结构：是指数据对象中数据元素之前的相互关系。分为以下四种：

### 集合结构

集合结构中的数据除了同属于一个集合之外，它们之前没有其他关系。

### 线性结构

数据元素是一对一的关系。

### 树形结构

数据元素之间存在一种一对多的层次关系。

### 图形结构

数据元素之间是多对多的关系

## 物理结构

数据的逻辑结构在计算机中的存储形式。

数据元素的存储结构形式有两种：顺序存储和链式存储。

### 顺序存储结构

是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和屋里关系是一致的。

存储关系反映了逻辑关系

### 链式存储结构

把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。

存储关系反映不了逻辑关系。



逻辑结构是面向问题的，而物理结构就是面向计算机的，其基本的目标就是将数据及其逻辑关系存储到计算机的内存中。



## 抽象数据类型

### 数据类型

是指一组性质相同的值的集合以及定义在此集合上的一些操作的总称。

在c语言中，数据类型分为：

原子类型：不可以再分解的基本类型，包括整型、实型、字符型等。

结构类型：由若干个类型组合而成，是可以再分解的。



#### 抽象数据类型 Abstract Data Type：ADT

指一个数学模型及定义在该模型上的一组操作。



## 算法 Algorithm

解决特定问题求解步骤的描述。在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

特性：

输入输出：有0个或多个输入，至少一个或多个输出

有穷性：执行有限步骤后，自动结束，每一步骤都在可接受的时间内完成。

确定性：每一步都有确定的含义，不会出现二义性

可行性：每一步都必须可行，也就是说，每一步都能够通过执行有限次数完成。



### 算法设计的要求

### 1. 正确性

算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。

但是算法的“正确”通常在用法上有很大的差别，大体分为以下四个层次。1．算法程序没有语法错误。2．算法程序对于合法的输入数据能够产生满足要求的输出结果。3．算法程序对于非法的输入数据能够得出满足规格说明的结果。4．算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。

一般满足层次3就行

### 2.可读性

便于阅读、理解和交流

可读性是算法（也包括实现它的代码）好坏很重要的标志。

### 3.健壮性

当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。

### 4.时间效率高和存储量低



综上，好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征。



## 算法效率的度量方法

### 1.事后统计法

通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。

但是这种方法有很大缺陷：

1. 花费大量时间和精力编制程序
2. 时间的比较依赖于计算机的软硬件
3. 算法的测试数据设计困难

### 2.事前分析估算法

算法程序在计算机上运行所消耗的时间取决于：

 1.算法采用的策略、方法。 

 2.编译产生的代码质量。 软件相关

3.问题的输 入规模。 

4.机器执行指令的速度。硬件相关

抛开软硬件不谈，程序运行时间依赖于 算法好坏与问题的输入规模

将基本操作的数量与输入规模关联起来。



#### 函数的渐进增长

给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的 n>N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。



### 算法时间复杂度

定义：算法的时间复杂度，也就是算法的时间量度，记 作:T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率 相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个 函数。

一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。

#### 推导大O阶方法

1. 用常数1取代运行时间中的所有加法常数。 

2. 在修改后的运行次数函数中，只保留最高阶项。 
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数。

#### 常数阶 O(1)

#### 线性阶O(n)

#### 对数阶O(logn)

#### 平方阶O(n^2^)

常见的时间复杂度所耗费的时间从小到达依次是：			 				 	

O(1)<O(logn)<O(n)<O(nlogn)<O(n^2^)<O(n^3^)<O(2^n^)<O(n!)<O(n^n^)



### 最坏情况与平均情况

对算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为 平均时间复杂度。另一种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时 间复杂度。一般在没有特殊说明的情况下，都是指最坏时间复杂度。



## 算法空间复杂度

算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记 作:S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。

一般情况下，一个程序在机器上执行时，**除了需要存储程序本身的指令、常数、变量 和输入数据外，**还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空 间复杂度为O(1)。