---
title： 线性表
---



# 线性表 

线性表（List）：0个或多个数据元素的有限序列

若将线性表记为(a1，...，ai-1，ai，ai+1，...，an)，则表中ai-1领先于ai，ai+1领先 于ai，称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。当i=1，2，...，n-1时， ai有且仅有一个直接后继，当i=2，3，...，n时，ai有且仅有一个直接前驱。

线性表元素的个数n(n≥0)定义为线性表的长度，当n=0时，称为空表。



### 线性表的抽象数据类型

线性表的抽象数据类型定义：

```shell
ADT 线性表(List)
Data
    线性表的数据对象集合为{a1,a2...an},每个元素的类型均为		DataType。
    除第一个元素外，每个元素有且仅有一个直接前驱元素。
    除最后一个元素外，每个元素有且仅有一个直接后继元素。
    数据元素之间的关系是一对一的关系。
Operation
    InitList(*L)：初始化操作，建立一个空的线性表
    ListEmpty(L): 判断线性表是否为空
    ClearList(*L): 将线性表清空
    GetElem(L, i, *e): 将馅饼表L中的第i个位置元素值返回给e
    Location(L, e): 在线性表中查找与给定值e相等的元素，如果查找成功就返回序号。
```



### 线性表的顺序存储结构

#### 顺序存储结构：

指的是用一段地址连续的存储单元依次存储线性表的数据元素。

```c
 /* 存储空间初始分配量 */
#define MAXSIZE 20
/* ElemType类型根据实际情况而定，这里假设为int */ 
typedef int ElemType;
typedef struct {
	/* 数组存储数据元素，最大值为MAXSIZE */ 
  ElemType data[MAXSIZE];
	/* 线性表当前长度 */
	int length;
} SqList;
```

描述顺序存储结构需要三个属性：

- 存储空间的起始位置
- 线性表的最大存储容量
- 线性表的当前长度

数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的。线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个 量是变化的。

在任意时刻，线性表的长度应该小于等于数组的长度。

#### 地址计算方法

由第一个元素的存储位置可以推算出任意第i个元素的存储位置：

LOC(a~i~) = LOC(a~1~)+(i-1)* c

所以，存取元素的时间复杂度为O(1)。这种存取结构成为随机存取结构。

#### 顺序存储结构的插入与删除

##### 获取元素操作

只要i在数组下边范围内，就可以返回，否则返回-1

时间复杂度O(1)

##### 插入操作

```js
// 在arr数组的第i个位置中插入ele
function insert(arr, i, ele) {
  let len = arr.length;
  if(i > len + 1 || i < 1) {
    return false
  }
  if(i <= len) {
    for(let k = len-1; k >= i -1; k--) {
      arr[k+1] = arr[k]
    }
  }
  arr[i-1] = ele;
  return arr
}
```

##### 删除操作

```js
function deleteEle(arr, i) {
  // 第i个元素
  let len = arr.length

  if (len === 0) return false

  if (i > len || i < 1) {
    return false
  }

  if (i < len) {
    for (let k = i; k < len; k++) {
      arr[k - 1] = arr[k]
    }
  }
  arr.length = len - 1
  return arr
}
```

时间复杂度O(n)

#### 线性表顺序存储结构的优缺点

优点：

- 无需为表示表中元素之间的逻辑关系而增加额外的存储空间
- 可以快速地存取表中任一位置的元素

缺点：

- 插入和删除操作需要移动大量元素
- 当线性表长度变化较大时，难以确定存储空间的容量
- 造成存储空间的“碎片”



### 线性表的链式存储结构

为了解决顺序存储结构的缺点（由于相邻元素的存储位置也代表着邻居关系，插入和删除时需要移动大量元素），用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。

链式结构中，除了要存数据元素信息外，还需要存储它后继元素的存储地址。

```c
typedef struct Node {
  ElemType data;
  struct Node *next;
} Node;
typedef struct Node *LinkList;
```



#### 单链表的读取和删除

读取的时间复杂度O(n) 和删除的时间复杂都是O(n)

首先需要找到目标节点，花费O(n)，真正的读取和删除只花费O(1)。

对于插入和删除数据比较频繁的操作，单链表的效率优势就越是明显。



#### 单链表的整表创建

动态结构。所占用的空间大小和位置是不需要预先分配划定的。

##### 头插法

##### 尾插法



#### 单链表的整表删除

算法思路：

1. 声明一个指针p和q；
2. 将第一个结点赋值给p；
3. 循环：
    - 将下一结点复制给q；
    - 释放p；
    - 将q赋值给p。



#### 单链表结构与顺序存储结构优缺点

**存储分配方式**：顺序存储结构用一段连续的存储单元依次存储线性表的数据元素；单链表采用链式存储结构，用一组任意的存储单元存当线性表的元素。

**时间性能**：查找：O(1) O(n);插入和删除：O(n)、单链表在找出某位置的指针后，插入和删除时间为O(1)。

**空间性能**：顺序存储结构需要预分配存储空间，分大了，浪费；链表不需要分配存储空间。



#### 静态链表



#### 循环链表 circle linked list

将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表成为单循环链表。

循环链表和单链表的主要差异就在于循环的判断条件上，原来为 p ->next === null,现在则是p->next ===头结点。

为了查找头结点和尾节点更快，可以用尾指针来表示循环链表。

![image-20230111222159935](https://raw.githubusercontent.com/diandianyezi/typora-images/master/img/202301112222018.png)



要将两个循环链表合并成一个表时，有了尾指针就非常简单了。

![image-20230111222406685](https://raw.githubusercontent.com/diandianyezi/typora-images/master/img/202301112224787.png)



#### 双向链表

#### 双向循环链表

##### 插入

将节点s插入到双向循环链表的p和q之间：

> s -> prior = p;
>
> s-> next = p->next
>
> p->next->prior = s
>
> p->next = s

先搞定s的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继。

##### 删除

删除节点p

> p->prior->next = p.next;
>
> p->next->prior = p->prior;
>
> free(p);

用空间来换时间



### 总结回顾

**线性表**：0个或多个具有相同类型的数据元素的有限序列。 

**顺序存储结构**：用一段地址连续的存储单元依次存储线性表的数据元素。用数组实现。

**链式存储结构**：不受固定的存储空间限制