---
title: js运算符
date: 2023-07-13
---

# js运算符

## in

用于判断属性是否存在于对象中。

语法：

```js
key in obj
```

- key:一个字符串类型或者 Symbol 类型的属性名或者数组索引（非 Symbol 类型将会强制转为字符串）。
- obj: 检查（或其原型链）是否包含具有指定名称的属性的对象。



- 内置对象、自定义对象都可用in检测属性
- 值为`undefined`的对象属性，也可以判断
- 继承属性，也会返回`true`

## instanceof

用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置。

```js
target instanceof constructor
```

### 检测类型

instanceof可以检测某个对象是否是另一个对象的实例。

instanceof可以检测父类型。



### 模拟实现

```js
function myInstanceof(left, right) {
  if(left === null || (typeof left !== 'object' && typeof left !== 'function')) return false;
  while(true) {
    if(left === null) return false;
    if(left === right.prototype) return true;
    left = left.__proto__;
  }
}
```



## delete

用于删除对象的某个属性。如果没有指向这个属性的引用了，它最终会被自动地释放。

```js
delete object.property;
delete object['property'];
```



### 返回值

对于所有情况都是true，除非属性是一个自己不可配置的属性，在这种情况下，非严格模式返回false。



### 说明

- 如果对象的原型链上有一个与待删除属性同名的属性，那么删除属性之后，对象会使用原型链上的那个属性（也就是说，`delete` 操作只会在自身的属性上起作用）
- 如果你试图删除的属性**不存在**，那么 `delete` 将不会起任何作用，但仍会返回 `true`
- 任何使用 `var` 声明的属性不能从全局作用域或函数的作用域中删除。
    - 这样的话，`delete` 操作不能删除任何在全局作用域中的函数（无论这个函数是来自于函数声明或函数表达式）
    - 除了在全局作用域中的函数不能被删除，在对象中的函数是能够用 `delete` 操作删除的。
- 任何用 `let` 或 `const` 声明的属性不能够从它被声明的作用域中删除。
- 不可设置的（Non-configurable）属性不能被移除。这意味着像 `Math`、`Array` 和 `Object` 等内置对象的属性以及使用 `Object.defineProperty()` 方法设置为不可设置的属性不能被删除。

## typeof

`typeof` 操作符返回一个字符串，表示未经计算的操作数的类型。

```js
typeof Math.LN2 === 'number';
typeof Infinity === 'number';

typeof Symbol() === 'symbol';
typeof Symbol('foo') === 'symbol';
typeof Symbol.iterator === 'symbol';

typeof null === 'object';
// 从一开始出现 JavaScript 就是这样的
```



## void

`void` 运算符能向期望一个表达式的值是 `undefined` 的地方插入会产生副作用的表达式。

- 替代`undefined`
- 客户端URL
- 阻止默认事件



## 字符串运算符

字符串运算符（+）用于将两个字符串值相连接。



## 算数运算符

算术运算符使用数值（字面量或者变量）作为操作数进行运算并返回一个数值。

当操作数是浮点数时，这些运算符表现得跟它们在大多数编程语言中一样（特殊要注意的是，除零会产生 `Infinity` ）。

- ** :指数运算符，计算base底数的exponent指数次方。



## 更新表达式

**前自增/自减运算符** 和 **后自增/自减运算符**。



### 对比

- **相同点**：无论是前自增/前自减还是后自增/后自减，对于变量而言，没有区别，都是自身`+1`/`-1`

- 不同点

    ：

    - 前自增/前自减：先自增/自减（变量自身），后赋值（将变量的值赋值给自增表达式的结果）
    - 后自增/后自减：先赋值，后自增/自减



#### 为什么后自增后自减优先级很高却后操作？

前置操作返回加（减）1 的值，所以返回对象本身，这是左值（`++i`，先自增后操作）

后置操作为右值，同样对其操作数 `+1`/`-1`，但操作后产生操作数原来的、未修改的值为表达式的结果（可理解为 `i++` 为先操作，后自增）。实际上，由于后自增（减）优先级很高，因此会先自增（减），但在自增（减）前会创建一个副本，用来保存操作数原来的值，操作后会返回副本的值给表达式。

建议：只有在必要时才使用后置操作符，尽量使用前置操作符。因为前置操作需要做的工作更少，而后置操作必须先保存操作数原来的值，对于 int 型对象和指针，编译器会优化掉这项额外的工作，但对于更多复杂的迭代器类型，这种额外的工作可能会花费更大的代价。



## 赋值运算符

将它右边操作数的值赋给它左边的操作数。

```js
* = /= %= += -= <<= >>= >>>= &= ^= |= **=
```



## 位移运算符

| 运算符     | 用法      | 描述                                                         |
| ---------- | --------- | ------------------------------------------------------------ |
| 按位与     | `a & b`   | 在 `a` `b`的位表示中，每一个对应的位都为 1 则返回 1， 否则返回 0 |
| 按位或     | `a | b`   | 在`a` `b`的位表示中，每一个对应的位，只要有一个为 1 则返回 1， 否则返回 0 |
| 按位异或   | `a ^ b`   | 在`a` `b`的位表示中，每一个对应的位，两个不相同则返回 1，相同则返回 0 |
| 按位非     | `~ a`     | 反转被操作数的位                                             |
| 左移       | `a << b`  | 将 `a` 的二进制串向左移动 `b` 位,右边移入 0                  |
| 算术右移   | `a >> b`  | 把 `a` 的二进制表示向右移动 `b` 位，丢弃被移出的所有位       |
| 无符号右移 | `a >>> b` | 把 `a` 的二进制表示向右移动 `b` 位，丢弃被移出的所有位，并把左边空出的位都填充为 0 |

### 最佳实践

#### 取整

使用 ~、 >>、 <<、 >>>、 | 来取整

#### 值交换

使用按位异或 ^ 来完成值交换

#### 十进制转二进制

####  颜色值转换

使用&、>>、|来完成RGB和16进制颜色值之间的转换

```js
/**
 * 16进制颜色值转RGB
 * @param  {String} hex 16进制颜色字符串
 * @return {String}     RGB颜色字符串
 */
function hexToRGB(hex) {
  var hexx = hex.replace('#', '0x');
  var r = hexx >> 16;
  var g = (hexx >> 8) & 0xff;
  var b = hexx & 0xff;
  return `rgb(${r}, ${g}, ${b})`;
}

/**
 * RGB颜色转16进制颜色
 * @param  {String} rgb RGB进制颜色字符串
 * @return {String}     16进制颜色字符串
 */
function RGBToHex(rgb) {
  var rgbArr = rgb.split(/[^\d]+/);
  var color = (rgbArr[1] << 16) | (rgbArr[2] << 8) | rgbArr[3];
  return '#' + color.toString(16);
}

// -------------------------------------------------
hexToRGB('#ffffff'); // 'rgb(255,255,255)'
RGBToHex('rgb(255,255,255)'); // '#ffffff'
```

#### 判断正负

```js
function isPos(n) {
  return n === n >>> 0 ? true : false;
}
isPos(-1); // false
isPos(1); // true
```

#### 判断符号是否相同

```js
console.log(-17 ^ (9 > 0));
// false
```

#### 判断奇偶

```js
// 偶数 & 1 = 0
// 奇数 & 1 = 1
console.log(2 & 1); // 0
console.log(3 & 1); // 1
```

