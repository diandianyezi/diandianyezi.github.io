---
title: js数据类型
date: 2023-07-12
---



# js数据类型

- js是一种弱类型语言或者动态语言。不用提前声明变量类型，在程序运行过程中，类型会被自动确定。

ECMAScript标准定义了原始数据类型和引用数据类型，共七种内置的数据类型：

- 原始数据类型（基本类型）：按值访问，可以操作保存在变量种实际的值。
    - 空值 null
    - 未定义 undefined
    - 布尔值 boolean
    - 数字 number
    - 字符串 string
    - 符号  symbol
- 引用类型（复杂数据类型）：引用类型的值是保存在内存中的对象。
    - 对象 Object
        - 布尔对象 Boolean
        - 数字对象 Number
        - 字符串对象 String
        - 函数对象 Function
        - 数组对象 Array
        - 日期对象 Date
        - 正则对象 RegExp
        - 错误对象 Error

> Javascript 不允许直接访问内存种的位置，引用类型的值是按引用访问的。



## 原始数据类型

### 空值

空值`null`是一个字面量，不像`undefined`是全局对象的一个属性。

`null`表示变量未指向任何对象。

### 未定义值

`undefined`是*全局对象*的一个属性。也就是说，它是全局作用域的一个变量。`undefined`的最初值就是原始数据类型`undefined`。

### 布尔值

布尔类型表示一个逻辑实体，可以有两个值：`true`和`false`。

### 数字

- 十进制
- 八进制：第一位必须是0
- 十六进制：前两位为0x

>  八进制在严格模式下 `"use strict"` 是无效的，会导致 JavaScript 报错，避免使用。

#### 浮点数

```js
const num = 0.1+0.2
console.info(num) // 0.30000000000000004
```

浮点型数据在计算时容易丢失精度，这一点并不仅在js中存在。

#### 数字的范围

- `Number.MIN_VALUE` 或 `Number.NEGATIVE_INFINITY`：表示 JavaScript 中的最小值
- `Number.MAX_VALUE` 或 `Number.POSITIVE_INFINITY`：表示 JavaScript 中的最大值
- `Infinity`：表示无穷大
- `-Infinity`：表示无穷小

#### NaN

NaN（Not a number）的含义是本该返回数值的操作未返回数值，返回了NaN就不会抛出异常影响语句流畅性。

`NaN` 属性的初始值就是 `NaN`，和 `Number.NaN` 的值一样。

```js
isNaN(NaN) // true
NaN !== NaN //true
```

### 字符串

JavaScript 的字符串类型用于表示文本数据。它是一组 16 位的无符号整数值的元素。

### 符号

`Symbol`是ECMAScript第6版中新定义的。该类型的性质在于这个类型的值可以用来创建匿名的对象属性。**该数据类型通常被用作一个对象属性的键值，当这个属性是用于类或对象类型的内部使用的时候。**

```js
var myPrivateMethod = Symbol();

this[myPrivateMethod] = function () {
  // ...
};
```



## 引用数据类型

对象是由new运算符加上要实例化的对象的名字创建的。

```js
var o = new Object();
```



## 类型检测

类型检测方法：

- `typeof`
- `instanceof`
- `Object.prototype.toStirng`
- `constructor`

### typeof

```js
typeof undefined;
// "undefined"

typeof null;
// "object"

typeof 100;
// "number"

typeof NaN;
// "number"

typeof true;
// "boolean"

typeof 'foo';
// "string"

typeof function () {};
// "function"

typeof [1, 2];
// "object"

typeof new Object();
// "object"
```

`typeof` 操作符适合对 **基本类型**（除 `null` 之外）及 `function` 的检测使用，而对引用数据类型（如 Array）等不适合使用。



### instanceof

`instanceof` 运算符用于检测一个对象在其 **原型链** 中是否存在一个构造函数的 `prototype` 属性。

- 左操作数为对象，不是返回false；
- 右操作数为函数对象或者函数构造器，不是就返回TypeError异常。

```js
obj instanceof constr;
```

```js
function Person() {}
function Student() {}
Student.prototype = new Person();
Student.prototype.constructor = Student;

const ben = new Student();
ben instanceof Student;
// true

const one = new Person();
one instanceof Person;
// true
one instanceof Student;
// false
ben instanceof Person;
// true
```

任何 一个构造函数都有一个`prototype`对象属性，这个对象属性将用作`new`实例化对象的原型对象。

> instanceof适合用于判断对象是否属于Array、Date和RegExp等内置对象。
>
> 不同 window 或 `iframe` 之间的对象类型检测无法使用 `instanceof` 检测。



### Object.prototype.toString

可以通过 `toString()`来获取每隔对象的类型。

为了 **每个对象** 都能通过 `Object.prototype.toString` 来检测，需要以 `Function.prototype.call` 或者 `Function.prototype.apply` 的形式来调用，传递要检查的对象作为第一个参数。

```javascript
Obejct.prototype.toString.call(undefined)；
//  "[object Undefined]"

Obejct.prototype.toString.call(null)；
//  "[object Null]"

Obejct.prototype.toString.call(true)；
//  "[object Boolean]"

Obejct.prototype.toString.call('')；
/// "[object String]"

Obejct.prototype.toString.call(123)；
//  "[object Number]"

Obejct.prototype.toString.call([])；
//  "[object Array]"

Obejct.prototype.toString.call({})；
//  "[object Object]"
```

> 使用 `Object.prototype.toString` 方法能精准地判断出值的数据类型。

> `Object.prototype.toString` 属于 `Object` 的原型方法，而 `Array` 或 `Function` 等类型作为 `Object` 的实例，都重写了 `toString` 方法。因此，不同对象类型调用 `toString` 方法时，调用的是重写后的 `toString` 方法，而非 `Object` 上原型 `toString` 方法，所以采用 `xxx.toString()` 不能得到其对象类型，只能将 `xxx` 转换成字符串类型。

### constructor

任何对象都有 `constructor` 属性，继承自原型对象，`constructor` 会指向构造这个对象的构造器或构造函数。

```js
Student.prototype.constructor === Student;
//  true
```

### 数组检测

ECMAScript5 将 `Array.isArray()` 正式引入 JavaScript，该方法能准确检测一个变量是否为数组类型。

```js
Array.isArray(variable);
```

