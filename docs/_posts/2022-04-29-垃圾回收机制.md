JavaScript 在执行函数时，会将其上下文压入栈中，ESP 上移，而当函数执行完成后，其执行上下文可以销毁了，此时仅需将 ESP下移到下一个函数执行上下文即可，当下一个函数入栈时，会将 ESP 以上的空间直接覆盖。垃圾回收

* 手动回收
* 自动回收：js中由垃圾回收器主动释放，

### 自动垃圾回收算法

1. 标记内存空间中的活动对象和非活动对象
2. 删除非活动对象，释放内存空间
3. 整理内存空间，避免频繁回收后产生大量内存碎片(不连续内存空间)

#### 标记-清除法

主要分为两个阶段

1. 第一个阶段为标记，从一个CG root集合出发，沿着指针找到所有对象，将其标记为活动对象。
2. 第二个阶段是清除，将内存中未被标记的对象删除，释放内存空间。

![image-20220428102620307](https://raw.githubusercontent.com/diandianyezi/typora-images/master/img/image-20220428102620307.png)

缺点：即在多次回收操作后，会产生大量的内存碎片，由于没有算法再整理空间，内存空间将变得很碎，此时，如果需要再申请一个较大的内存空间，即便剩余内存总大小足够，也很容易因为没有足够的连续内存而分配失败。

#### 复制算法

基于上述标记算法所产生的的问题，1963年出现了著名的复制算法。

1. 将整个空间平均分为from 和 to两部分。
2. 先在from空间进行内存分配，当空间被占满时，标记活动对象，并将其复制到to空间。
3. 复制完成后，将from和to空间互换。

![image-20220428103223845](https://raw.githubusercontent.com/diandianyezi/typora-images/master/img/image-20220428103223845.png)

由于直接将活动对象复制到另一半空间，，没有了清除阶段的开销，所以能在较短时间内完成回收操作，并且每次复制的时候，对象都会集中到一起，相当于做了整理操作，避免内存碎片的产生。

虽然有吞吐量高、没有碎片的优点，但其缺点也非常明显。首先，复制操作也是需要时间成本的，若堆空间很大且活动对象很多，则每次清理时间会很久，其次，将空间二等分的操作，让可用内存空间直接减少了一半。

#### 引用计数

1. 实时统计指向对象的引用数（指针数量）
2. 当引用数为0时，实时回收对象

![image-20220428103641386](https://raw.githubusercontent.com/diandianyezi/typora-images/master/img/image-20220428103641386.png)

该算法可以即时回收垃圾数据，对程序的影响时间很短，效率很高。高性能、实时回收，看似很完美其实有个问题，当对象中存在循环引用时，由于引用数不会降到0，所以对象不会被回收。

![image-20220428103836237](https://raw.githubusercontent.com/diandianyezi/typora-images/master/img/image-20220428103836237.png)

#### 标记-压缩算法

1970年出现，结合了标记-清除法和复制发的优点

1. 从一个CG root集合触发，标记所有活动对象；
2. 将所有活动对象移到内存的一端，集中到一起。
3. 直接清理调边界以外的内存，释放连续空间。

![image-20220428104041276](https://raw.githubusercontent.com/diandianyezi/typora-images/master/img/image-20220428104041276.png)

缺点：

由于清除和整理的操作很麻烦，甚至需要对整个堆做多次搜索，顾问堆越大，耗时越多。

#### 代际假设和分代收集

经调查发现，大多数应用程序内的数据有以下两个特点：

- 大多数对象的生命周期很短，很快就不再被需要了
- 哪些一直存活的对象通常会存在很久

对象的生存时间有两极分化情况

**「分代收集：」** 所以可以将对象进行分代，从而对不同分代实施不同的垃圾回收算法，以达到更高的效率（如 Java GC: https://plumbr.io/handbook/garbage-collection-in-java/generational-hypothesis）。



### JS垃圾回收

js的原始数据类型存储在栈中，引用数据类型存在堆中

#### 栈中垃圾回收

> ESP(Extended Stack Pointer): 扩展栈指针寄存器，用于存放函数栈顶指针。

JavaScript 在执行函数时，会将其上下文压入栈中，ESP 上移，而当函数执行完成后，其执行上下文可以销毁了，此时仅需将 ESP下移到下一个函数执行上下文即可，当下一个函数入栈时，会将 ESP 以上的空间直接覆盖。

下移ESP完成栈的垃圾回收。

![image-20220428105340655](https://raw.githubusercontent.com/diandianyezi/typora-images/master/img/image-20220428105340655.png)

#### 堆中垃圾回收

需要用到垃圾回收器

JavaScript 堆中垃圾数据回收就使用到了分代收集的思想，引擎将堆空间分为 **「新生代(young-space)」** 和 **「老生代(old-space)」** ，并且对两个区域实施不同的垃圾回收策略：**复制算法和标记-压缩算法。**

------

**「新生代：」** 新生代用于存放生存时间短的对象，大多数新创建的小的对象都会被分配到该区域，该区域的垃圾回收会比较频繁。

在新生代中，**引擎使用 Scavenge 算法(https://v8.dev/blog/trash-talk) 进行垃圾回收，即上面提到的复制算法。**

其将新生代空间对半分为 `from-space` 和 `to-space` 两个区域。新创建的对象都被存放到 `from-space`，当空间快被写满时触发垃圾回收。先对 `from-space` 中的对象进行标记，完成后将标记对象复制到 `to-space` 的一端，然后将两个区域角色反转，就完成了回收操作。

由于每次执行清理操作都需要复制对象，而复制对象需要时间成本，所以新生代空间会设置得比较小（1~8M）。

------

**「老生代：」** 老生代被用于存放生存时间长的对象和大的对象：

- 即一些大的对象会被直接分配到老生代空间
- **新生代中经过两次垃圾回收后仍然存活的对象，会晋升到老生代空间**

------

引擎在该空间主要使用上面提到的 **「标记-压缩算法」** 。首先对活动对象进行标记，标记完成后，将所有存活对象移到内存的一段，然后清理掉边界外的内存。

由于 JavaScript 是单线程运行的，意味着垃圾回收算法和脚本任务在同一线程内运行，在执行垃圾回收逻辑时，后续的脚本任务需要等垃圾回收完成后才能继续执行。若堆中的数据量非常大，一次完整垃圾回收的时间会非常长，将导致应用的性能和响应能力都直线下降。

**为了避免垃圾回收影响应用的性能，V8 将标记的过程拆分成多个子标记，让垃圾回收标记和应用逻辑交替执行，避免脚本任务等待较长时间。**